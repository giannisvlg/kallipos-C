# 2. Εισαγωγικές έννοιες στον προγραμματισμό με τη C

## 2.1 Εισαγωγή

Η C είναι μια μικρή γλώσσα και αυτό αποτελεί μια στρατηγική σχεδιαστική απόφαση των δημιουργών της. Σε αυτό το πνεύμα οι δεσμευμένες λέξεις στη C είναι σχετικά λίγες. Οι βασικές δεσμευμένες λέξεις περιλαμβάνονται στον Πίνακα 2.1(1). 
{ .annotate }

1.  Στη C υπάρχουν και άλλες δεσμευμένες λέξεις που έχουν προστεθεί κατά την εξέλιξη των προτύπων της γλώσσας (π.χ.<span class="p-style">inline</span> και <span class="p-style">restrict</span> στη C99, _StaticAssert στη C11 κ.ά.)


+---------+---------+-------------------+-------------------+-------------------+-------------------+-------------------+-------------------+
| auto    | double  | int               | struct            | break             | else              | long              | switch            |
+---------+---------+-------------------+-------------------+-------------------+-------------------+-------------------+-------------------+
| case    | enum    | register          | typedef           | char              | extern            | return            | union             |
+---------+---------+-------------------+-------------------+-------------------+-------------------+-------------------+-------------------+
| const   | float   | short             | unsigned          | continue          | for               | signed            | void              |
+---------+---------+-------------------+-------------------+-------------------+-------------------+-------------------+-------------------+
| default | goto    | sizeof            | volatile          | do                | if                | static            | while             |
+---------+---------+-------------------+-------------------+-------------------+-------------------+-------------------+-------------------+





Βασικό συστατικό τμήμα κάθε προγράμματος στη C είναι η συνάρτηση <span class="p-style">main()</span> που λειτουργεί ως σημείο εισόδου (entry point) για την εκτέλεση του προγράμματος. Η συνάρτηση <span class="p-style">main()</span> συνήθως γράφεται όπως στη συνέχεια.

```{.text .nocopy}
int main(void) {
    // Ο κώδικας του προγράμματος τοποθετείται εδώ
    return 0;
}
```
To <span class="p-style">void</span> εντός των παρενθέσεων της <span class="p-style">main()</span>, στη γραμμή 1, υποδηλώνει ότι η <span class="p-style">main()</span> δεν δέχεται παραμέτρους. Ωστόσο, η <span class="p-style">main()</span> μπορεί να γραφεί και ως <span class="p-style">int main(int argc, char *argv[])</span> έτσι ώστε να δέχεται ορίσματα γραμμής εντολών όπως θα δούμε στο Κεφάλαιο 6. Το σώμα της συνάρτησης <span class="p-style">main()</span>, δηλαδή ότι περιέχεται ανάμεσα στις αγκύλες μετά το <span class="p-style">main()</span>, περιέχει τον κώδικα που θα εκτελεστεί, άρα εκείκαθορίζεται η ροή εκτέλεσης του προγράμματος. Στη γραμμή 2 του κώδικα υπάρχει ένα σχόλιο που η αρχήτου υποδηλώνεται με το //. Η εντολή <span class="p-style">return</span> στο τέλος της <span class="p-style">main()</span> χρησιμοποιείται για να καθορίσει την κατάσταση του προγράμματος κατά την έξοδο, δηλαδή αν το πρόγραμμα επιτέλεσε σωστά τις λειτουργίες του ή αν προκλήθηκε κατά την εκτέλεση κάποια «μη φυσιολογική» κατάσταση. Η επιστροφή της τιμής 0 συμβατικά υποδηλώνει την επιτυχή εκτέλεση, ενώ μη μηδενικές τιμές υποδηλώνουν ότι το πρόγραμμα τερματίστηκε ανώμαλα.


### 2.1.1 Εισαγωγή

Μέσα στον κώδικα μπορούν να προστίθενται επεξηγηματικά σχόλια που θα αγνοηθούν κατά τη μεταγλώττιση και εκτέλεση του προγράμματος. Τα σχόλια μπορούν να τεκμηριώνουν τον σκοπό, τη λειτουργικότητα ή το σκεπτικό με το οποίο έχει γραφεί ο κώδικας. Εφόσον πράγματι κομίζουν κάποια χρήσιμη πληροφορία, διευκολύνουν την κατανόηση και συντήρηση του κώδικα από τον ίδιο τον προγραμματιστή ή από άλλους προγραμματιστές. Στη C υπάρχουν δύο είδη σχολίων, τα σχόλια μιας γραμμής και τα σχόλια πολλαπλών γραμμών. Όπως ήδη αναφέρθηκε, τα σχόλια μιας γραμμής ξεκινούν με το // και συνεχίζουν μέχρι το τέλος της γραμμής. Τα σχόλια πολλαπλών γραμμών περικλείονται ανάμεσα σε /* και */ όπως στο ακόλουθο παράδειγμα.

```{.text .nocopy}
/* Αυτό είναι 
ένα σχόλιο
πολλαπλών γραμμών */  
```

## 2.2 Τύποι δεδομένων και μεταβλητές

Μια μεταβλητή είναι μια περιοχή συνεχόμενων θέσεων στη μνήμη του υπολογιστή στην οποία αποδίδεται από τον προγραμματιστή ένα όνομα. Κατά τη διάρκεια εκτέλεσης ενός προγράμματος οι μεταβλητές αποθηκεύουν δεδομένα που τροποποιούνται έτσι ώστε να εξυπηρετούν την επιδιωκόμενη κατά περίπτωση αλγοριθμική συμπεριφορά. Τυπικά, μια μεταβλητή αποτελείται από όνομα, διεύθυνση μνήμης, τύπο δεδομένων, τιμή, διάρκεια ζωής (life cycle) και εμβέλεια (scope). Το όνομα είναι το αναγνωριστικό της μεταβλητής που χρησιμοποιεί ο προγραμματιστής για να αναφερθεί σε αυτή. Η διεύθυνση της μεταβλητής είναι η διεύθυνση μνήμης όπου βρίσκονται τα περιεχόμενα της μεταβλητής. Ο τύπος δεδομένων της (π.χ. ακέραιος, πραγματικός κ.λπ.) καθορίζει το είδος δεδομένων που μπορεί να αποθηκεύσει και τις λειτουργίες που μπορούν να εκτελεστούν σε αυτά τα δεδομένα. Η τιμή της μεταβλητής έχει να κάνει με την ερμηνεία των δυαδικών ψηφίων που υπάρχουν στις θέσεις μνήμης που καταλαμβάνει η μεταβλητή στη μνήμη και εξαρτάται από τον τύπο δεδομένων της. Η διάρκεια ζωής της είναι η χρονική περίοδος που η μεταβλητή υφίσταται στη μνήμη και διατηρεί την τιμή της. Τέλος, η εμβέλεια αναφέρεται στο τμήμα του προγράμματος που η μεταβλητή είναι προσπελάσιμη και μπορεί να χρησιμοποιηθεί. Η δήλωση μιας μεταβλητής έχει την ακόλουθη μορφή:

```{.text .nocopy}
τύπος_δεδομένων όνομα_μεταβλητής;
```

### 2.2.1 Τύποι δεδομένων στη C

Οι βασικοί τύποι δεδομένων στην C είναι ο <span class="p-style">char</span>, ο <span class="p-style">int</span>, ο <span class="p-style">float</span> και ο <span class="p-style">double</span>, όπως φαίνεται και στον
Πίνακα 2.2. Επιπλέον, υπάρχουν οι προσδιοριστές (qualifiers) <span class="p-style">short</span> (ακέραια αριθμητική τιμή μικρού εύρους), <span class="p-style">long</span> (αριθμητική τιμή μεγάλου εύρους), <span class="p-style">signed</span> (προσημασμένος) και <span class="p-style">unsigned</span> (μη προσημασμένος, περιέχει μόνο μη αρνητικές τιμές) που μπορούν να εφαρμοστούν σε ορισμένους, κατά περίπτωση, βασικούς τύπους και να αλλάξουν το μέγεθος που καταλαμβάνουν στη μνήμη και συνεπώς και το εύρος τιμών που μπορούν να αναπαραστήσουν ή και την ακρίβεια αν πρόκειται για πραγματικούς αριθμούς. Για παράδειγμα ο προσδιοριστής short μπορεί να εφαρμοστεί μόνο σε ακεραίους και εγγυάται μέγεθος τουλάχιστον 2 bytes = 16 bits, άρα καλύπτει εύρος ακεραίων τιμών τουλάχιστον  
από −2^15^ = −32768 έως 2^15^ − 1 = 32767. Για να δηλωθεί μια μεταβλητή x ως τύπου δεδομένων short αυτό μπορεί να γίνει ως <span class="p-style">signed short int x;</span> ή ως <span class="p-style"> short int x;</span> ή ως <span class="p-style"> short  x;</span> με το τελευταίο και συντομότερο να προτιμάται.

<div style="text-align: center;"><b>Πίνακας 2.2: </b><i> Οι βασικοί τύποι δεδομένων της C.</i></div>

| Βασικός τύπος δεδομένων | Περιγραφή                                                                 |
|-------------------------|---------------------------------------------------------------------------|
| char                    | χαρακτήρας, μπορεί να χρησιμοποιηθεί και ως μικρός ακέραιος               |
| int                     | ακέραιος αριθμός                                                          |
| float                   | πραγματικός αριθμός κινητής υποδιαστολής απλής ακρίβειας                  |
| double                  | πραγματικός αριθμός κινητής υποδιαστολής εκτεταμένης ακρίβειας            |



Μπορεί να γραφεί ένα πρόγραμμα που θα εμφανίζει για κάθε αποδεκτό συνδυασμό προσδιοριστών και βασικών τύπων δεδομένων το μέγεθος του τύπου δεδομένων σε bytes και το εύρος τιμών που είναι σε θέση να απεικονίσει ο τύπος. Ένα τέτοιο πρόγραμμα υπάρχει στο Παράρτημα Γ. Μεταγλωττίζοντας και εκτελώντας το μπορούμε να παρατηρήσουμε ότι το ίδιο πρόγραμμα επιστρέφει διαφορετικές τιμές για ορισμένες ποσότητες ανάλογα με τον συνδυασμό μεταγλωττιστή (είδους και έκδοσής του) και πλατφόρμας στην οποία εκτελείται ο κώδικας.

Στη συνέχεια παρουσιάζονται δύο παραδείγματα εκτέλεσης, ένα σε υπολογιστή 64 bits, με λειτουργικό σύστημα Linux και μεταγλώττιση με τον GCC 13.1.0 και ένα σε σύστημα 32 bits με λειτουργικό σύστημα Linux και μεταγλώττιση με μια σχετικά παλιά έκδοση του clang την 3.8.0 (κυκλοφόρησε το 2016). Τα αποτελέσματα είναι διαφορετικά για τους long αριθμούς, τόσο τους signed όσο και τους unsigned, καθώς στη μια περίπτωση το μέγεθος είναι 8 bytes ενώ στην άλλη είναι 4 bytes. Επίσης στους long double, αν και το εύρος τους είναι ίδιο, το μέγεθος είναι 16 bytes στην πρώτη περίπτωση αλλά μόνο 12 bytes στη δεύτερη περίπτωση. Οι διαφορές θα ήταν περισσότερες αν η σύγκριση αφορούσε ένα σύστημα 16 bits. Για παράδειγμα οι μεταγλωττιστές της C για συστήματα 16 bits συνήθως θεωρούν ότι οι τιμές τύπου int καταλαμβάνουν 2 bytes, γεγονός που περιορίζει το εύρος τους από -32768 μέχρι και 32767. Υπάρχουν πολλά τέτοια συστήματα στον χώρο των ενσωματωμένων συστημάτων όπως είναι o μικροελεγκτής MSP430 της Texas Instruments που έχει αρχιτεκτονική 16 bit.


```
GCC 13.1.0 detected
Platform: 64 bits
Data Type(Storage Size)                 Value Range
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
char (1 byte)                           ‐128 to 127
unsigned char (1 byte)                  0 to 255
signed char (1 byte)                    ‐128 to 127
int (4 bytes)                           ‐2147483648 to 2147483647
unsigned int (4 bytes)                  0 to 4294967295
short (2 bytes)                         ‐32768 to 32767
unsigned short (2 bytes)                0 to 65535
long (8 bytes)                          ‐9223372036854775808 to 9223372036854775807
unsigned long (8 bytes)                 0 to 18446744073709551615
long long 8 bytes                       ‐9223372036854775808 to 9223372036854775807
unsigned long long (8 bytes)            0 to 18446744073709551615
float (4 bytes)                         1.175494e‐38 to 3.402823e+38
double (8 bytes)                        2.225074e‐308 to 1.797693e+308
long double (16 bytes)                  3.362103e‐4932 to 1.189731e+4932
```
<div style="text-align: center;"><i>Linux 64 bits, GCC 13.1.0 με ημερομηνία κυκλοφορίας την 26/4/2023.</i></div>  

```
clang 3.8.0 detected
Platform: 32 bits
Data Type(Storage Size)                 Value Range
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
char (1 byte)                           ‐128 to 127
unsigned char (1 byte)                   0 to 255
signed char (1 byte)                    ‐128 to 127
int (4 bytes)                           ‐2147483648 to 2147483647
unsigned int (4 bytes)                   0 to 4294967295
short (2 bytes)                         ‐32768 to 32767
unsigned short (2 bytes)                 0 to 65535
long ( 4 bytes )                        ‐2147483648 to 2147483647
unsigned long ( 4 bytes )                0 to 4294967295
long long (8 bytes)                     ‐9223372036854775808 to 9223372036854775807
unsigned long long (8 bytes)             0 to 18446744073709551615
float (4 bytes)                          1.175494e‐38 to 3.402823e+38
double (8 bytes)                         2.225074e‐308 to 1.797693e+308
long double ( 12 bytes )                 3.362103e‐4932 to 1.189731e+4932
```
<div style="text-align: center;"><i>Linux 32 bits, clang 3.8.0 με ημερομηνία κυκλοφορίας την 8/3/2016.</i></div>

Για την εκτύπωση των παραπάνω τιμών χρησιμοποιείται o τελεστής <span class="p-style">sizeof</span> για το μέγεθος που καταλαμβάνει σε μνήμη η κάθε τιμή, ενώ για τα εύρη τιμών των τύπων δεδομένων χρησιμοποιούνται σταθερές όπως η <span class="p-style">INT_MAX</span> (μέγιστη τιμή για τον ακέραιο τύπο δεδομένων) που ορίζονται στις επικεφαλίδες <span class="p-style">limits.h</span> και <span class="p-style">float.h</span>. O σύντομος κώδικας 2.1 που ακολουθεί, εμφανίζει τιμές μόνο για τους τύπους δεδομένων <span class="p-style">int</span> και <span class="p-style">double</span>.

```{.c title="ch2_p1.c" linenums="1"}
--8<-- "src/ch2_p1.c"
```
<b>Κώδικας 2.1:</b> <i>ch2_p1.c - εμφάνιση μεγέθους σε bytes και εύρους τιμών για μεταβλητές τύπου δεδομένων int και
τύπου δεδομένων double.</i>


Η εκτέλεση του προγράμματος θα δώσει τα ακόλουθα αποτελέσματα:

```
int (4 bytes)           ‐2147483648 to 2147483647
double (8 bytes)         2.225074e‐308 to 1.797693e+308
```


Οι εντολές στις γραμμές 6 και 7 του κώδικα θα εξηγηθούν στη συνέχεια του κεφαλαίου.  

<i>Φορητοί τύποι δεδομένων</i> Καθώς βασικοί τύποι δεδομένων όπως ο <span class="p-style">int</span> μπορεί να έχουν διαφορετικό μέγεθος και εύρος τιμών ανάλογα με τον μεταγλωττιστή και την αρχιτεκτονική του συστήματος, προέκυψε η ανάγκη για φορητούς τύπους δεδομένων, δηλαδή τύπους που η συμπεριφορά τους να είναι η ίδια ανεξάρτητα από μεταγλωττιστή και υπολογιστικό σύστημα. Έτσι, στο πρότυπο C99 εισήχθησαν για τους ακεραίους νέοι τύποι όπως ο <span class="p-style">uint32_t</span> που σημαίνει ότι πρόκειται για μη προσημασμένο (unsigned) ακέραιο των 32 bits, οπότε είναι εγγυημένο ότι το εύρος τιμών του είναι από 0 έως και 232 − 1 = 4294967295. Ο τύπος <span class="p-style">uint32_t</span> και οι αντίστοιχοι τύποι για 8, 16 και 64 bits ορίζονται στο stdint.h μαζί και με άλλους τύπους δεδομένων όπως για παράδειγμα τύπους που δίνουν έμφαση στην ταχύτητα εκτέλεσης (π.χ. <span class="p-style">int_fast32_t</span>) ή στο μέγεθος που καταλαμβάνουν στη μνήμη (π.χ. <span class="p-style">int_least64_t</span>).  

Ένας ακόμα φορητός τύπος δεδομένων είναι ο <span class="p-style">size_t</span> που ορίζεται στην <span class="p-style">stdef.h</span>, αλλά και σε άλλες επικεφαλίδες  (π.χ. στην <span class="p-style">stdlib.h</span>), και εγγυάται ότι μπορεί να αναπαραστήσει το μέγεθος του μεγαλύτερου αντικειμένου στη μνήμη που υποστηρίζεται από την υλοποίηση. Πρόκειται για τον τύπο επιστροφής του τελεστή <span class="p-style">sizeof</span> που θα συναντήσουμε και στη συνέχεια. Οι τιμές του <span class="p-style">size_t</span> είναι πάντα μη αρνητικές και χρησιμοποιείται συχνά ως τύπος δεδομένων μεταβλητών επανάληψης, αλλά και για την αποθήκευση αποτελεσμάτων που είναι μη αρνητικά (π.χ. μήκος ενός λεκτικού).

## 2.3 Σταθερές

Τα προγράμματα C συνήθως περιέχουν κάποιες σταθερές τιμές. Κάθε σταθερή τιμή έχει τύπο δεδομένων και
υπάρχουν ειδικοί συμβολισμοί για τη διευκρίνιση του τύπου δεδομένων που επιθυμούμε να αποδώσουμε. Έτσι:

- Οι χαρακτήρες τοποθετούνται σε απλά εισαγωγικά, π.χ. <span class="p-style">'a'</span>.
- Οι τιμές <span class="p-style">unsigned</span> υποδηλώνονται με το επίθεμα <span class="p-style">u</span> ή το <span class="p-style">U</span>, π.χ. 42U.
- Οι τιμές <span class="p-style">long</span> έχουν ως επίθεμα το <span class="p-style">l</span> ή το <span class="p-style">L</span>, π.χ. 120L.
- Οι τιμές <span class="p-style">long long</span> έχουν ως επίθεμα το <span class="p-style">ll</span> ή το <span class="p-style">LL</span>, π.χ. 120LL.
- Οι τιμές <span class="p-style">unsigned long</span> και <span class="p-style">unsigned long long</span> γράφονται με <span class="p-style">ul</span> (ή με <span class="p-style">UL</span>) και με <span class="p-style">ull</span> (ή με <span class="p-style">ULL</span>) αντίστοιχα, π.χ. 42ULL.
- Οι τιμές τύπου <span class="p-style">float</span> έχουν ως επίθεμα το <span class="p-style">f</span> ή το <span class="p-style">F</span>, π.χ. 3.14159F.  


Στη C υπάρχουν και οι «μεταβλητές μόνο για ανάγνωση» που λαμβάνουν μια αρχική τιμή που δεν επιτρέπεται να αλλάξει στη συνέχεια του προγράμματος. Αυτό γίνεται με τη δεσμευμένη λέξη <span class="p-style">const</span>. Για παράδειγμα:

```
const float PI=3.14159; // μεταβλητή μόνο για ανάγνωση
```

Εναλλακτικά προς τις μεταβλητές μόνο για ανάγνωση μπορούν να οριστούν οι λεγόμενες συμβολικές σταθερές που ορίζονται με την οδηγία <span class="p-style">define</span> όπως στο ακόλουθο παράδειγμα.

```
#define PI 3.14159 // συμβολική σταθερά
```

Παρατηρήστε ότι δεν υπάρχει ; στο τέλος της #define PI 3.14159. Η <span class="p-style">define</span> είναι οδηγία προς τον προεπεξεργαστή, ένα τμήμα του μεταγλωττιστή της C, που πραγματοποιεί αντικαταστάσεις κειμένου πριν την πραγματική μεταγλώττιση του κώδικα. Περισσότερα για τον προεπεξεργαστή αναφέρονται στο Κεφάλαιο 12.

## 2.4 Δηλώσεις και ορισμοί μεταβλητών

Η C είναι γλώσσα statically typed (στατικών τύπων) που σημαίνει ότι οι τύποι δεδομένων μεταβλητών και σταθερών καθορίζονται και ελέγχονται κατά τον χρόνο μεταγλώττισης, και όχι στον χρόνο εκτέλεσης. Έτσι, οι μεταβλητές χρειάζεται να δηλωθούν προσδιορίζοντας τύπο δεδομένων και όνομα και στη συνέχεια να οριστεί η τιμή τους. Αυτό μπορεί να γίνει σε δύο ξεχωριστές εντολές ή σε μια μόνο εντολή όπως στη συνέχεια.

```
int x; // δήλωση ακέραιας μεταβλητής
x = 42; // ορισμός τιμής για τη μεταβλητή x
int y = 1729; // δήλωση και ορισμός τιμής για τη μεταβλητή y
```

Τα ονόματα των μεταβλητών σχηματίζονται με γράμματα της αγγλικής αλφαβήτου, ψηφία και την κάτω παύλα, ενώ δεν πρέπει να ξεκινούν με ψηφίο ή να περιέχουν κενά. Δεν επιτρέπεται η χρήση δεσμευμένων λέξεων ως ονόματα μεταβλητών και υπάρχει διάκριση ανάμεσα σε κεφαλαία και πεζά γράμματα, δηλαδή η <span class=p-style>C</span> είναι case sensitive (π.χ. τα αναγνωριστικά <span class=p-style>myvar</span> και <span class=p-style>myvaR</span> είναι διαφορετικά). Τα ονόματα των μεταβλητών πρέπει να επιλέγονται με συνέπεια, να έχουν νόημα στα πλαίσια του γενικότερου κώδικα και να διευκολύνουν την ανάγνωσή του. Πολύ μικρά ή πολύ μεγάλα ονόματα μεταβλητών μπορεί να δυσχεραίνουν την κατανόηση του κώδικα και τη συντήρησή του.

## 2.5 Είσοδος/Έξοδος

Η εμφάνιση αποτελεσμάτων στην οθόνη και η είσοδος τιμών από το πληκτρολόγιο αποτελούν βασικό τρόπο αλληλεπίδρασης του χρήστη με τον υπολογιστή. Στη συνέχεια θα εξεταστούν οι συναρτήσεις <span class="p-style">printf()</span> και <span class="p-style">scanf()</span> που οι δηλώσεις τους υπάρχουν στο <span class="p-style">stdio.h</span>. Υπάρχουν και άλλες συναρτήσεις εισόδου/εξόδου της C όπως είναι οι <span class="p-style">getc()</span>, <span class="p-style">putc()</span>, <span class="p-style">fgets()</span>, <span class="p-style">fprintf()</span> για τις οποίες θα γίνουν σε επόμενες παραγράφους σύντομες αναφορές.


### 2.5.1 Η συνάρτηση printf()

Η <span class="p-style">printf()</span> επιτρέπει τη μορφοποιημένη εμφάνιση ορισμάτων της στο τερματικό. Η δήλωση της συνάρτησης στο <span class="p-style">stdio.h</span> είναι η ακόλουθη:

```
int printf(const char* format, ...);
```
Η συνάρτηση επιστρέφει μια ακέραια τιμή που είναι το πλήθος των χαρακτήρων που εκτυπώνει ή μια αρνητική τιμή αν συμβεί κάποιο σφάλμα. Η πρώτη παράμετρος που δέχεται είναι το λεγόμενο «αλφαριθμητικό μορφοποίησης» (format string) που συνήθως περιέχει προσδιοριστές μορφοποίησης (format specifiers) που ξεκινούν με το σύμβολο <span calss="p-style">%</span> και που αντικαθίστανται από τις τιμές των επόμενων παραμέτρων. Οι τρεις τελείες που ακολουθούν στη λίστα παραμέτρων στην παραπάνω δήλωση της συνάρτησης <span class="p-style">printf()</span> σημαίνουν ότι η συνάρτηση μπορεί να δεχθεί μεταβλητό πλήθος ορισμάτων. Πρέπει να υπάρχει συμφωνία στο πλήθος των προσδιοριστών μορφοποίησης που υπάρχουν στο λεκτικό του πρώτου ορίσματος με το πλήθος των ορισμάτων που ακολουθούν. Στο αλφαριθμητικό μορφοποίησης μπορούν να χρησιμοποιηθούν ακολουθίες διαφυγής (escape sequences ή escape characters) όπως το <span class="p-style">\n</span>, που προκαλεί αλλαγή γραμμής. Η σημασία των κυριότερων ακολουθιών διαφυγής παρουσιάζεται στον Πίνακα 2.3.

<b>Πίνακας 2.3:</b><i>Χαρακτήρες διαφυγής που μπορούν να χρησιμοποιηθούν στο αλφαριθμητικό μορφοποίησης της
printf().</i>

| Ακολουθία διαφυγής  | Περιγραφή                                                          |
|---------------------|--------------------------------------------------------------------|
| <div style="text-align: center;">\"</div>  | Διπλά εισαγωγικά                                                   |
| <div style="text-align: center;">\'</div>  | Απλά εισαγωγικά                                                   |
| <div style="text-align: center;">\\</div>  | Ανάστροφο σλας (backslash)                                         |
| <div style="text-align: center;">\0</div>  | Χαρακτήρας NULL (τερματισμός στα αλφαριθμητικά)                   |
| <div style="text-align: center;">\a</div>  | Ήχος (καμπανάκι)                                                   |
| <div style="text-align: center;">\b</div>  | Οπισθοχώρηση μιας θέσης (backspace)                                |
| <div style="text-align: center;">\t</div>  | Στηλοθέτης (tab)                                                  |
| <div style="text-align: center;">\n</div>  | Αλλαγή γραμμής                                                     |
| <div style="text-align: center;">\xHH</div> | Δεκαεξαδική αναπαράσταση χαρακτήρα (HH είναι η δεκαεξαδική τιμή)   |

<div style="text-align: center;">Ο κώδικας 2.2 αποτελεί ένα παράδειγμα επίδειξης λειτουργίας ακολουθιών διαφυγής με την <span class="p-style">printf()</span>.</div>

```{.c title="Κώδικας 2.2: ch2_p2.c - παραδείγματα χρήσης ακολουθιών διαφυγής στο αλφαριθμητικό μορφοποίησης της printf()." linenums="1"}
--8<-- "src/ch2_p2.c"
```
<div style="text-align: center;">Η έξοδος του προγράμματος είναι η ακόλουθη:</div>
```{.text .nocopy}
$ gcc ch2_p2.c -o ch2_p2 -Wall -Wextra -pedantic -std=c17
$ ./ch2_p2
This string contains newline characters 
New Line
This string contains a tab character    Tabbed Text
This string contains a backslash character \
This string contains "Double Quotes"
This string contains 'Single Quotes'
This string contains backspace characters:Learn plain C
This string makes a beep sound
This string contains a hexadecimally encoded symbol √
This string contains the NULL character
```
Βέβαια, ο κύριος λόγος χρήσης της <span class="p-style">printf()</span> είναι η εμφάνιση αποτελεσμάτων. Στο πρόγραμμα που ακολουθεί (κώδικας 2.3) παρουσιάζονται ορισμένες από τις σημαντικότερες δυνατότητες που παρέχει η <span class="p-style">printf()</span> για μορφοποιημένη έξοδο τιμών.

```{.c title="Κώδικας 2.3: ch2_p3.c - παραδείγματα μορφοποιημένης εξόδου με την printf." linenums="1"}
--8<-- "src/ch2_p3.c"
```

```
Integer: 42
Float: 3.141590
Character and its int value : A 65
String: Hello, World!
Octal: 52 Hexadecimal: 2a
Width and Padding :             42
Padding with zeros:       00000042
Precision: 3.14
Left‐alignment : |Hello, World!          |
Right‐alignment: |          Hello, World!|
Print % character: %

```

Ο πίνακας 2.4 δείχνει προσδιοριστές μορφοποίησης που χρησιμοποιούνται συχνά.

<div style="text-align: center;"><b>Πίνακας 2.4:</b><i> Προσδιοριστές μορφοποίησης που χρησιμοποιούνται συχνά στην printf().</i></div>

| <div style="text-align: center;">Προσδιοριστής μορφοποίησης</div> | <div style="text-align: center;">Τύπος δεδομένων</div> | Περιγραφή                                                                   |
|------------------------------------------------------------|----------------------------------------------------|-----------------------------------------------------------------------------|
| <div style="text-align: center;">%d</div>                    | <div style="text-align: center;">int</div>           | Ακέραιος                                                                   |
| <div style="text-align: center;">%o</div>                    | <div style="text-align: center;">int</div>           | Ακέραιος στο οκταδικό σύστημα                                               |
| <div style="text-align: center;">%x ή %X</div>               | <div style="text-align: center;">int</div>           | Ακέραιος στο δεκαεξαδικό σύστημα                                            |
| <div style="text-align: center;">%u</div>                    | <div style="text-align: center;">unsigned int</div>  | Μη προσημασμένος ακέραιος                                                  |
| <div style="text-align: center;">%ld</div>                   | <div style="text-align: center;">long</div>          | Ακέραιος long                                                              |
| <div style="text-align: center;">%lld</div>                  | <div style="text-align: center;">long long</div>     | Ακέραιος long long                                                         |
| <div style="text-align: center;">%f</div>                    | <div style="text-align: center;">float ή double</div>| Πραγματικός απλής ή διπλής ακρίβειας                                        |
| <div style="text-align: center;">%e ή %E</div>               | <div style="text-align: center;">float ή double</div>| Επιστημονικός συμβολισμός                                                   |
| <div style="text-align: center;">%g ή %G</div>               | <div style="text-align: center;">float ή double</div>| Εμφάνιση είτε με δεκαδικά ψηφία είτε με επιστημονικό συμβολισμό ανάλογα με την τιμή |
| <div style="text-align: center;">%Lf</div>                   | <div style="text-align: center;">long double</div>    | Πραγματικός εκτεταμένης ακρίβειας                                           |
| <div style="text-align: center;">%c</div>                    | <div style="text-align: center;">char</div>           | Χαρακτήρας                                                                  |
| <div style="text-align: center;">%s</div>                    | <div style="text-align: center;">char*</div>          | Αλφαριθμητικό                                                              |
| <div style="text-align: center;">%p</div>                    | <div style="text-align: center;">void*</div>          | Διεύθυνση δείκτη                                                           |
| <div style="text-align: center;">%zu</div>                   | <div style="text-align: center;">long long</div>      | Για εκτύπωση μεταβλητών size_t                                              |


Η συνάρτηση <span class="p-style">printf</span> κατευθύνει τα μηνύματα στην οθόνη. Ωστόσο, η οθόνη είναι μια μόνο από τις διαθέσιμες επιλογές. Η C λειτουργεί με τα λεγόμενα ρεύματα εξόδου (output streams). Αν επιθυμούμε την κατεύθυνση μηνυμάτων σε κάποιο άλλο ρεύμα εξόδου, όπως για παράδειγμα ένα αρχείο, τότε μπορεί να χρησιμοποιηθεί η συνάρτηση <span class="p-style">fprintf()</span> που δέχεται ως επιπλέον πρώτο όρισμα σε σχέση με την <span class="p-style">printf()</span>, το ρεύμα εξόδου. Στο παράδειγμα που ακολουθεί (κώδικας 2.4) χρησιμοποιούνται τα ρεύματα εξόδου <span class="p-style">stdout</span> και <span class="p-style">stderr</span>.


```{.c title="Κώδικας 2.4: ch2_p4.c - χρήση των ρευμάτων stdin και stderr για την κατεύθυνση της εξόδου." linenums="1"}
--8<-- "src/ch2_p4.c"
```
Η εκτέλεση του προγράμματος εμφανίζει:
```
Info: 42/2 = 21
Error: division by zero if 42/0 is to be attempted
```

Το <span class="p-style">stdout</span> είναι το ρεύμα εξόδου όπου κατευθύνεται η «κανονική» έξοδος προγραμμάτων και τυπικά αντιστοιχεί στην κονσόλα, οπότε εμφανίζει μηνύματα στην οθόνη. Το ρεύμα εξόδου <span class="p-style">stderr</span> επίσης τυπικά αντιστοιχεί στην κονσόλα, αλλά χρησιμοποιείται για εμφάνιση σφαλμάτων, πέρα από τη φυσιολογική πορεία εκτέλεσης του προγράμματος. Πρακτικά, η χρήση του <span class="p-style">stderr</span> αποτελεί έναν τυποποιημένο τρόπο χειρισμού των σφαλμάτων που καθιστά ευκολότερο τον εντοπισμό και την επίλυση προβλημάτων. Συμπερασματικά, η <span class="p-style">printf()</span> είναι μια συνάρτηση με πολλές δυνατότητες. Μια καλή περιγραφή των «μυστικών» της <span class="p-style">printf()</span> βρίσκεται στο [^1].

### 2.5.2 Η συνάρτηση scanf()

Η συνάρτηση <span class="p-style">scanf()</span> επιτρέπει την εισαγωγή τιμών που πληκτρολογεί ο χρήστης σε μεταβλητές. Η δήλωσή της στο <span class="p-style">stdio.h</span> είναι η ακόλουθη:

```
int scanf(const char* format, ...);
```
Η συνάρτηση επιστρέφει μια ακέραια τιμή που είναι το πλήθος των τιμών που διάβασε επιτυχώς. Η πρώτη παράμετρος της <span class="p-style">scanf()</span> είναι αλφαριθμητικό που περιέχει προσδιοριστές για τις τιμές που πληκτρολογεί ο χρήστης. Για κάθε προσδιοριστή πρέπει να αντιστοιχεί μια μεταβλητή στη λίστα ορισμάτων. H <span class="p-style">scanf()</span> απαιτεί τα ορίσματα να δίνονται ως διευθύνσεις μνήμης των μεταβλητών. Στη C η διεύθυνση μιας απλής μεταβλητής λαμβάνεται με τον τελεστή <span class="p-style">&</span>. Στο ακόλουθο πρόγραμμα (κώδικας 2.5) ο χρήστης εισάγει τιμές διαφόρων τύπων δεδομένων με την <span class="p-style">scanf()</span>.

```{.c title="Κώδικας 2.5: ch2_p5.c - ανάγνωση ακεραίων τιμών, πραγματικών τιμών και αλφαριθμητικών με τη scanf()." linenums="1"}
--8<-- "src/ch2_p5.c"
```

Ένα παράδειγμα εκτέλεσης του παραπάνω προγράμματος φαίνεται στη συνέχεια:

```
Enter 2 int values : 1
2
i1=1, i2=2
Enter 2 float values : 1.4 3.7
f1=1.400000, f2=3.700000
Enter a string: Hello
s=Hello
```

### 2.5.3 Ιδιαιτερότητες της scanf() και άλλες συναρτήσεις εισόδου/εξόδου

Η <span class="p-style">scanf()</span> δίνει στον προγραμματιστή τη δυνατότητα να διαβάσει οποιαδήποτε δεδομένα (π.χ. αριθμούς, αλφαριθμητικά) από το πληκτρολόγιο. Ωστόσο, υπάρχουν μερικές λεπτομέρειες χρήσης της αλλά και άλλες συναρτήσεις εισόδου που είναι χρήσιμο να γνωρίζει κανείς έτσι ώστε να αποφύγει γνωστά και συνηθισμένα προβλήματα. Καθώς η εισαγωγή αλφαριθμητικών από το χρήστη είναι μια πολύ συνηθισμένη λειτουργία,
παρά το ότι στο Κεφάλαιο 8 θα αναφερθούμε αναλυτικά στα αλφαριθμητικά, θα επισημάνουμε εδώ ότι ένα αλφαριθμητικό στη C με δυνατότητα αποθήκευσης κειμένου 10 χαρακτήρων(1) διαβάζεται και εκτυπώνεται με τον κώδικα 2.6.
{ .annotate }

1.  Ένα αλφαριθμητικό 10 χαρακτήρων χρειάζεται χώρο 11 χαρακτήρων για αποθήκευση, διότι τα αλφαριθμητικά στη C έχουν
ως τελευταίο χαρακτήρα το λεγόμενο NULL χαρακτήρα (ή NULL terminator) που σηματοδοτεί το τέλος του αλφαριθμητικού



```{.c title="Κώδικας 2.6: ch2_p6.c - είσοδος αλφαριθμητικού με τη scanf()." linenums="1"}
--8<-- "src/ch2_p6.c"
```

Η εκτέλεση του κώδικα με είσοδο χρήστη το “Caesar” (αλφαριθμητικό 6 χαρακτήρων) θα εμφανίσει:

```
Input text:Caesar
You entered:|Caesar|
```
Ωστόσο, αν δοκιμάσουμε άλλες εισόδους θα λάβουμε κάποια «περίεργα» αποτελέσματα. Δύο τέτοιες περιπτώσεις θα εξετάσουμε στη συνέχεια.  

<i>Αποφυγή υπερχείλισης αλφαριθμητικού</i> Αν εισαχθεί ένα κείμενο όπως το “JuliusCaesar” (12 χαρακτήρων), τότε θα συμβεί υπερχείλιση στη μεταβλητή s, καθώς δεν θα επαρκεί ο δεσμευμένος χώρος για αποθήκευση της εισόδου. Η υπερχείλιση δημιουργεί διάφορα προβλήματα καθώς δεδομένα γράφονται σε θέσεις που δεν θα έπρεπε. Στο συγκεκριμένο παράδειγμα απλά θα εμφανιστούν όλοι οι χαρακτήρες που εισήγαγε ο χρήστης, όμως σε άλλες περιπτώσεις οι συνέπειες θα μπορούσαν να είναι δραματικές. Η αποφυγή υπερχείλισης με αποκοπή των επιπλέον χαρακτήρων μπορεί να γίνει εύκολα αντικαθιστώντας την <span class="p-style">scanf("%s", s)</span> με <span class="p-style">scanf("10%s", s)</span>. Τότε θα αποθηκευτούν και θα εμφανιστούν οι 10 πρώτοι χαρακτήρες της εισόδου, δηλαδή η έξοδος θα είναι <span class="p-style">You entered:|JuliusCaes|</span>.  

<i>Είσοδος με κενούς χαρακτήρες</i> Ένα δεύτερο πρόβλημα εμφανίζεται όταν το κείμενο της εισόδου έχει κενά. Για παράδειγμα για είσοδο “Mea Culpa” η έξοδος είναι   
<span class="p-style">You entered:|Mea|</span>. Το πιθανότερο είναι να θέλαμε να αποθηκευτεί το σύνολο της φράσης ως αλφαριθμητικό. Για να συμβεί αυτό η κλήση της συνάρτησης <span class="p-style">scanf()</span> θα πρέπει να γίνει <span class="p-style">scanf("%10[^\n]s", s</span>). Τότε, η έξοδος θα είναι <span class="p-style">You entered:|Mea Culpa|</span>. Ένας άλλος τρόπος να επιτευχθεί το ίδιο αποτέλεσμα είναι να χρησιμοποιηθεί η συνάρτηση <span class="p-style">fgets()</span> όπως στον κώδικα 2.7 που ακολουθεί:



```{.c title="Κώδικας 2.7: ch2_p7.c, είσοδος αλφαριθμητικού με την fgets()." linenums="1"}
--8<-- "src/ch2_p7.c"
```

Η κλήση της συνάρτησης <span class="p-style">fgets()</span> στη γραμμή 6 δέχεται ως ορίσματα τη μεταβλητή όπου θα αποθηκευθεί η είσοδος του χρήστη, το πλήθος των χαρακτήρων που θα περιέχει η μεταβλητή (συμπεριλαμβανομένου του <span class="p-style">'\0'</span>) και το <span class="p-style">stdin</span> που είναι το προκαθορισμένο ρεύμα εισόδου, που τυπικά είναι συνδεδεμένο με το πληκτρολόγιο, δηλαδή δέχεται ότι πληκτρολογεί ο χρήστης.



#### Διαδοχικές scanf()

H <span class="p-style">scanf()</span> χρησιμοποιεί μια ενδιάμεση μνήμη (buffer) όπου αποθηκεύονται προσωρινά τα δεδομένα που εισάγονται από το πληκτρολόγιο. Αν για παράδειγμα εισαχθεί ένας ακέραιος, τότε ο buffer θα έχει τον ακέραιο και την αλλαγή γραμμής. Αν η είσοδος αυτή «καταναλωθεί» από τη <span class="p-style">scanf()</span> με οδηγία να αναγνωσθεί ένας ακέραιος, τότε θα αφαιρεθεί από το buffer ο ακέραιος μόνο και όχι η αλλαγή γραμμής. Έτσι αν ακολουθήσει και δεύτερο <span class="p-style">scanf()</span> με οδηγία ανάγνωσης ενός χαρακτήρα, τότε ο χαρακτήρας θα λάβει από τον buffer την αλλαγή γραμμής και δεν θα ζητηθεί η εισαγωγή άλλης τιμής. Αυτή συμπεριφορά παρατηρείται στον κώδικα 2.8 που ζητά από τον χρήστη να εισάγει την ηλικία και την τάξη ενός μαθητή.

```{.c title="Κώδικας 2.8: ch2_p8.c - προβλήματα στην είσοδο δεδομένων με τη scanf()." linenums="1"}
--8<-- "src/ch2_p8.c"
```

Ακολουθεί η έξοδος του προγράμματος για ένα παράδειγμα δεδομένων εισόδου (π.χ. ηλικία 7, τάξη A).
```
Enter age and grade:7
Age=7 Grade=
```
Η επιδιόρθωση του κώδικα γίνεται απλά αντικαθιστώντας την κλήση της συνάρτησης scanf() με την κλήση scanf(" %c", &grade). Δώστε προσοχή στο κενό πριν το %c που αποτελεί οδηγία προς τη scanf() να αγνοήσει κενούς χαρακτήρες αν υπάρχουν πριν την τιμή που θα χρησιμοποιηθεί ως είσοδος. Με την αλλαγή αυτή ο κώδικας λειτουργεί όπως θα θέλαμε.
```
Enter age and grade:7
A
Age=7 Grade=A
```

#### Οι συναρτήσεις getc() και putc()

Δύο χρήσιμες συναρτήσεις μη μορφοποιημένης εισόδου και εξόδου είναι η <span class="p-style">getc()</span> και η <span class="p-style">putc()</span>. Η <span class="p-style">getc()</span> διαβάζει έναν χαρακτήρα από ένα ρεύμα εισόδου και η <span class="p-style">putc()</span> τοποθετεί έναν χαρακτήρα σε ένα ρεύμα εξόδου. Αν χρησιμοποιηθεί το <span class="p-style">stdin</span> για ρεύμα εισόδου και το <span class="p-style">stdout</span> για ρεύμα εξόδου, τότε η είσοδος γίνεται από το πληκτρολόγιο και η έξοδος γίνεται στην οθόνη. Ο κώδικας 2.9 αποτελεί ένα παράδειγμα χρήσης των συναρτήσεων <span class="p-style">getc()</span> και <span class="p-style">putc()</span>.


```{.c title="Κώδικας 2.9: ch2_p9.c - ανάγνωση και εμφάνιση ενός χαρακτήρα." linenums="1"}
--8<-- "src/ch2_p9.c"
```

Υποθέτοντας ότι ο χρήστης εισάγει τον χαρακτήρα a, το πρόγραμμα θα εμφανίσει τα ακόλουθα.
```
Enter a character: a
You entered: a
You entered 'a' which is at ASCII position 97 (display using printf)
```

## 2.6 Τελεστές

Οι τελεστές (operators) είναι πράξεις που εφαρμόζονται πάνω σε δεδομένα που αναφέρονται ως τελεστέοι (operands). Αν ο τελεστής εφαρμόζεται σε έναν μόνο τελεστέο τότε είναι μοναδιαίος (unary), αν εφαρμόζεται σε δύο τελεστέους είναι δυαδικός (binary) και αν εφαρμόζεται σε τρεις τελεστέους είναι τριαδικός (ternary). Οι τελεστές επίσης διακρίνονται σε σχέση με το είδος της πράξης που εκτελούν σε αριθμητικούς, συγκριτικούς, λογικούς, χειρισμού δυαδικών ψηφίων κ.λπ. Θα ξεκινήσουμε την περιήγηση στους τελεστές με τον τελεστή ανάθεσης τιμής <span class=p-style>=</span>.

### 2.6.1 Τελεστής αν'αθεσης τιμής

Μια εντολή ανάθεσης τιμής έχει την ακόλουθη σύνταξη:
```
όνομα_μεταβλητής = έκφραση;
```

Στο αριστερό μέρος του τελεστή <span class=p-style>=</span> βρίσκεται μια μεταβλητή και στο δεξί μέρος μια έκφραση που υπολογίζεται και η τιμή της ανατίθεται στη μεταβλητή. Ένα ενδιαφέρον χαρακτηριστικό του τελεστή ανάθεσης τιμής στη C είναι ότι μπορεί να χρησιμοποιηθεί για να ανατεθεί τιμή σε πολλές μεταβλητές με μια μόνο εντολή όπως στο ακόλουθο απόσπασμα κώδικα, όπου και οι τρεις μεταβλητές λαμβάνουν την τιμή 10.
```
x = y = z = 10;
```
Αυτό συμβαίνει διότι ο τελεστής ανάθεσης τιμής έχει προσεταιριστικότητα από δεξιά προς τα αριστερά (right-to-left associativity). Έτσι στο παράδειγμα γίνεται μια σειρά από αλυσιδωτές αναθέσεις τιμών, όπου η τιμή 10 ανατίθεται πρώτα στο <span classs=p-style>z</span> και στη συνέχεια η τιμή του <span classs=p-style>z</span> ανατίθεται στο <span classs=p-style>y</span> και μετά η τιμή του <span classs=p-style>y</span> ανατίθεται στο <span classs=p-style>x</span>, έτσι ώστε στο τέλος και οι τρεις μεταβλητές να έχουν την ίδια τιμή.

### 2.6.2 Αριθμητικοί τελεστές

Οι αριθμητικοί τελεστές της C είναι οι <span class=p-style>+</span>, <span class=p-style>‐</span>, <span class=p-style>*</span>, <span class=p-style>/</span> και <span class=p-style>%</span>. Ο τελεστής <span class=p-style>/</span> όταν εφαρμόζεται σε ακεραίους πραγματοποιεί ακέραια διαίρεση, και ο τελεστής <span class=p-style>%</span> υπολογίζει το υπόλοιπο της ακέραιας διαίρεσης. Οι υπόλοιποι τελεστές έχουν την αναμενόμενη λειτουργία που περιμένουμε από την αριθμητική. Ο τελεστής <span class=p-style>‐</span> μπορεί να λειτουργήσει, είτε ως δυαδικός τελεστής (π.χ. <span class=p-style>x = 1 ‐ 2;</span>) είτε ως μονομελής για να δηλώσει το αρνητικό πρόσημο μιας έκφρασης (π.χ. <span class=p-style>x = ‐3;</span>). Στη συνέχεια ακολουθεί ένα πρόγραμμα (κώδικας 2.10), που παρουσιάζει παραδείγματα πράξεων με αριθμητικούς τελεστές.

```{.c title="Κώδικας 2.10: ch2_p10.c - πράξεις με τους αριθμητικούς τελεστές." linenums="1"}
--8<-- "src/ch2_p10.c"
```

Τα αποτελέσματα εκτέλεσης του προγράμματος παρουσιάζονται στη συνέχεια.

```
15 / 7 = 2, 15 % 7 = 1
7 / 15 = 0, 7 % 15 = 7
15.0 / 7.0 = 2.14
15 / 7.0 = 2.14
15.0 / 7 = 2.14
```

<i>Ο τελεστής <span class=p-style>+=</span> και άλλοι τελεστές πράξης ανάθεσης</i> Οι αριθμητικοί τελεστές συνδυάζονται στη C με τον τελεστή ανάθεσης τιμής προκειμένου να αποτελέσουν συντομότερους τρόπους συγγραφής εντολών. Έτσι, για παράδειγμα η εντολή <span class=p-style>x = x + 5;</span> μπορεί να γραφεί ως <span class=p-style>x += 5;</span>. Εκτός από τον τελεστή <span class=p-style>+=</span> (addition assignment), υπάρχουν και οι τελεστές <span class=p-style>*=</span>, <span class=p-style>/=</span>, <span class=p-style>‐=</span> και <span class=p-style>%=</span> με αντίστοιχες λειτουργίες.

<i>Τελεστές μοναδιαίας αύξησης και μοναδιαίας μείωσης</i> Η μοναδιαία αύξηση και η μοναδιαία μείωση της τιμής μιας μεταβλητής είναι μια πολύ κοινή πράξη στον προγραμματισμό, σε βαθμό που οι σχεδιαστές της C θεώρησαν ότι πρέπει να υπάρχει ένας συντομότερος τρόπος από το <span class=p-style>x = x + 1;</span> ή το <span class=p-style>x += 1;</span> για την εντολή αυτή, οπότε και επιλέχθηκε ο συμβολισμός <span class=p-style>x++;</span> και αντίστοιχα <span class=p-style>x‐‐;</span> για τη μείωση κατά ένα. Μια ιδιαιτερότητα των τελεστών αυτών είναι ότι μπορούν να χρησιμοποιηθούν, είτε προθεματικά (prefix) σε μια μεταβλητή (π.χ. <span class=p-style>++x;</span>), είτε επιθεματικά (postfix), όπως στο παράδειγμα που αναφέρθηκε. Η διαφορά ανάμεσα στους δύο τρόπους εφαρμογής εμφανίζεται όταν μια έκφραση με τον τελεστή <span class=p-style>++</span> ή τον <span class=p-style>‐‐</span> εμφανίζεται σε μια παράσταση. Αν ο τελεστής χρησιμοποιείται προθεματικά όπως για παράδειγμα στο <span class=p-style>x = 10; y = ++x + 5;</span> τότε εκτελείται η πράξη της μοναδιαίας αύξησης και με αυτήν την τιμή η μεταβλητή συμμετέχει στον υπολογισμό της παράστασης, οπότε το αποτέλεσμα στο παράδειγμα θα είναι <span class=p-style>x = 11</span>, <span class=p-style>y = 16;</span>. Αν από την άλλη μεριά ο κώδικας χρησιμοποιούσε τον τελεστή <span class=p-style>++</span> επιθεματικά, όπως στο <span class=p-style>x = 10; y = x++ + 5;</span> τότε στην έκφραση υπολογισμού του <span class=p-style>y</span> θα χρησιμοποιούνταν η τιμή 10 για το <span class=p-style>x</span> και τα αποτελέσματα θα ήταν <span class=p-style>x = 11</span>, <span class=p-style>y = 15;</span>.
Ακολουθεί ο σχετικός κώδικας (κώδικας 2.11) και τα αποτελέσματα εκτέλεσής του.

```{.c title="Κώδικας 2.11: ch2_p11.c - παράδειγμα με τον τελεστή μοναδιαίας αύξησης." linenums="1"}
--8<-- "src/ch2_p11.c"
```
```
Prefix increment example: x=11, y=16
Postfix increment example: x=11, y=15
```
### 2.6.3 Συγκριτικοί τελεστές

Οι συγκριτικοί τελεστές είναι οι <span class=p-style><</span>, <span class=p-style><=</span>, <span class=p-style>></span>, <span class=p-style>>=</span>,<span class=p-style>==</span> (έλεγχος ισότητας) και <span class=p-style>!=</span> (έλεγχος ανισότητας). Είναι εύκολο για κάποιον αρχάριο προγραμματιστή να μπερδέψει τον τελεστή ανάθεσης τιμής <span class=p-style>=</span> με τον συγκριτικό τελεστή ελέγχου ισότητας <span class=p-style>==</span>, καθώς ο μεταγλωττιστής δεν θα εμφανίσει μήνυμα σφάλματος αν γραφεί για παράδειγμα <span class=p-style>x = 1</span> αντί για <span class=p-style>x == 1</span>. Ένας τρόπος για να αποφευχθεί αυτό είναι σε περίπτωση που μια μεταβλητή συγκρίνεται με μια σταθερά ή με μια έκφραση να γράφεται στο δεξί μέρος του ελέγχου η μεταβλητή  
(π.χ. <span class=p-style>1 == x</span>, αντί για <span class=p-style>x == 1</span>). Καθώς η C δεν διέθετε πριν την έκδοση C99 λογικό τύπο δεδομένων, υπάρχει η εξής σύμβαση. Η τιμή 0 θεωρείται ψευδής και η τιμή 1 αληθής, όπως και όλες οι ακέραιες τιμές πλην του μηδενός. Για παράδειγμα αν ανατεθεί μια λογική έκφραση σε μια ακέραια μεταβλητή, αν η λογική έκφραση είναι ψευδής τότε η μεταβλητή θα λάβει τιμή 0, ενώ αν είναι αληθής θα λάβει την τιμή 1. Αυτό φαίνεται στο ακόλουθο πρόγραμμα
(κώδικας 2.12).

```{.c title="Κώδικας 2.12: ch2_p12.c - το 0 ως ψευδές και το 1 ως αληθές." linenums="1"}
--8<-- "src/ch2_p12.c"
```

```
1 > 2 is evaluated as 0
2 <= 2 is evaluated as 1
```

<i>Ο τύπος bool </i> Ο τύπος <span class=p-style>bool</span> ενσωματώθηκε επίσημα στη C με το πρότυπο C99. Έτσι, μπορούν να χρησιμοποιηθούν οι συμβολικές σταθερές <span class=p-style>true</span> και <span class=p-style>false</span> σε προγράμματα C. Σε αυτήν την περίπτωση πρέπει να γίνει include το <span class=p-style>stdbool.h</span>

### 2.6.4 Λογικοί τελεστές

Οι λογικοί τελεστές είναι οι <span class=p-style>&&</span>, <span class=p-style>||</span>, <span class=p-style>!</span> και είναι το λογικό ΚΑΙ (AND), το λογικό Ή (OR) και το λογικό ΌΧΙ (NOT) αντίστοιχα. Οι λογικοί τελεστές επιτρέπουν τη σύνταξη σύνθετων λογικών εκφράσεων όπως για παράδειγμα η (<span class=p-style>x > 5 && x <=10) || x == 20</span> που αποτιμάται ως αληθής για οποιαδήποτε τιμή του <span class=p-style>x</span> μεγαλύτερη του 5 και μικρότερη ή ίση του 10 ή αν το <span class=p-style>x</span> έχει την τιμή 20. Ο πίνακας αληθείας για τους
λογικούς τελεστές παρουσιάζεται στον Πίνακα 2.5.

<div style="text-align: center;"><b>Πίνακας 2.5:</b><i> Λογικοί τελεστές - πίνακας αληθείας.</i></div>

| p             | q             | p && q        | p \|\| q      | !p            |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| ΨΕΥΔΗΣ (0)    | ΨΕΥΔΗΣ (0)    | ΨΕΥΔΗΣ (0)    | ΨΕΥΔΗΣ (0)    | ΑΛΗΘΗΣ (1)    |
| ΨΕΥΔΗΣ (0)    | ΑΛΗΘΗΣ (1)    | ΨΕΥΔΗΣ (0)    | ΑΛΗΘΗΣ (1)    | ΑΛΗΘΗΣ (1)    |
| ΑΛΗΘΗΣ (1)    | ΨΕΥΔΗΣ (0)    | ΨΕΥΔΗΣ (0)    | ΑΛΗΘΗΣ (1)    | ΨΕΥΔΗΣ (0)    |
| ΑΛΗΘΗΣ (1)    | ΑΛΗΘΗΣ (1)    | ΑΛΗΘΗΣ (1)    | ΑΛΗΘΗΣ (1)    | ΨΕΥΔΗΣ (0)    |

<i>Εσπευσμένη αποτίμηση λογικών εκφράσεων</i> Υπάρχει περίπτωση μια σύνθετη λογική έκφραση να μπορεί να αποτιμηθεί χωρίς να εξεταστούν όλοι οι όροι της. Για παράδειγμα αν πολλές λογικές εκφράσεις συνδέονται με τον τελεστή <span class=p-style>&&</span> τότε αν ξεκινώντας από αριστερά εντοπιστεί μια λογική έκφραση που είναι ψευδής, δεν χρειάζεται να αποτιμηθούν οι υπόλοιπες εκφράσεις καθώς γνωρίζουμε ότι η σύνθετη έκφραση θα είναι ψευδής. Ομοίως, αν μια σύνθετη λογική έκφραση αποτελείται από λογικές εκφράσεις που συνδέονται με το <span class=p-style>||</span> τότε αν κατά την αποτίμηση της σύνθετης έκφρασης εντοπιστεί μια συνθήκη που είναι αληθής, τότε οι συνθήκες που απομένουν δεν αποτιμώνται καθώς η τιμή τους δεν πρόκειται να επηρεάσει την αληθή τιμή της σύνθετης λογικής έκφρασης που θα είναι σε κάθε περίπτωση αληθής. Ο τρόπος αυτός αποτίμησης σύνθετων λογικών εκφράσεων στη C αναφέρεται και ως short circuit (βραχυκύκλωμα) και μερικές φορές μπορεί να έχει μη επιθυμητά αποτελέσματα. Ένα παράδειγμα δίνεται στη συνέχεια στον κώδικα 2.13, όπου παρά το ότι υπάρχει στη γραμμή 6 πράξη διαίρεσης ακεραίου με μηδέν, που θα δημιουργούσε σφάλμα εκτέλεσης, ο κώδικας ολοκληρώνει την εκτέλεσή του κανονικά καθώς η αποτίμηση της σύνθετης λογικής έκφρασης γίνεται χωρίς να αποτιμάται ποτέ η έκφραση <span class=p-style>(10/x) > 1</span> μιας και η έκφραση <span class=p-style>x == 0</span> είναι αληθής.


```{.c title="Κώδικας 2.13: ch2_p13.c - αποφυγή σφάλματος εκτέλεσης λόγω εσπευσμένης αποτίμησης λογικής έκφρασης." linenums="1"}
--8<-- "src/ch2_p13.c"
```

Η έξοδος του προγράμματος είναι η ακόλουθη

```
The logic expression 's value is 1.
```

### 2.6.5 Τελεστές χειρισμού δυαδικών ψηφίων

Οι τελεστές χειρισμού δυαδικών ψηφίων της C είναι οι <span class=p-style>&</span> (bitwise and), <span class=p-style>|</span> (bitwise or), <span class=p-style>^</span> (bitwise xor), <span class=p-style><<</span> (ολίσθηση προς τα αριστερά), <span class=p-style>>></span> (ολίσθηση προς τα δεξιά) και <span class=p-style>~</span> (συμπλήρωμα ως προς ένα). Οι τελεστές αυτοί εκτελούν πράξεις σε επίπεδο δυαδικού ψηφίου. O Πίνακας 2.6 παρουσιάζει τη λειτουργία των τελεστών <span class=p-style>&</span>,<span class=p-style>|</span>,<span class=p-style>^</span>,<span class=p-style>~</span>. Ο τελεστής του συμπληρώματος ως προς ένα αντιστρέφει τα bits του τελεστέου.

<div style="text-align: center;"><b>Πίνακας 2.6:</b><i> Τελεστές χειρισμού δυαδικών ψηφίων.</i></div>


| x     | y     | x & y     | x \| y    | x^y   | ~x    |
|:-----:|:-----:|:---------:|:---------:|:-----:|:-----:|
| 0     | 0     | 0         | 0         | 0     | 1     |
| 0     | 1     | 0         | 1         | 1     | 1     |
| 1     | 0     | 0         | 1         | 1     | 0     |
| 1     | 1     | 1         | 1         | 0     | 0     |

Οι τελεστές ολίσθησης μετατοπίζουν τα bits του αριστερού τελεστέου τους ένα πλήθος θέσεων (που είναι
η τιμή του δεξιού τελεστέου), είτε προς τα αριστερά είτε προς τα δεξιά. Για παράδειγμα ο τελεστής αριστερής
ολίσθησης <span class=p-style><<</span> αν εφαρμοστεί στην τιμή 12 που έχει τη δυαδική αναπαράσταση 00001100 με δεξί τελεστέο την τιμή 2, θα μετατοπίσει όλα τα ψηφία του 00001100 κατά 2 θέσεις προς τα αριστερά δίνοντας την τιμή 48 που αναπαρίσταται δυαδικά ως 00110000. Αξίζει να σημειωθεί ότι η μετατόπιση των ψηφίων ενός δυαδικού αριθμού κατά ένα ψηφίο προς τα αριστερά ισοδυναμεί με διπλασιασμό του, ενώ η μετατόπιση προς τα δεξιά με υποδιπλασιασμό του (π.χ. η αριστερή ολίσθηση <span class=p-style>7 << 1</span> θα επιστρέψει 14, ενώ η δεξιά ολίσθηση <span class=p-style>7 >> 1</span> θα επιστρέψει 3).

Ο κώδικας 2.14 δείχνει παραδείγματα λειτουργίας των bitwise τελεστών.
```{.c title="Κώδικας 2.14: ch2_p14.c - παράδειγμα χρήσης τελεστών χειρισμού δυαδικών ψηφίων." linenums="1"}
--8<-- "src/ch2_p14.c"
```

Λάβετε υπόψη ότι μια unsigned int τιμή έχει 32 bits. Τα αποτελέσματα εκτέλεσης είναι τα ακόλουθα.

```
Bitwise AND: 8
Bitwise OR: 14
Bitwise XOR: 6
Bitwise NOT on 12: 4294967283
Left Shift: 48
Right Shift: 5
```

#### 2.6.5.1 Μάσκες δυαδικών ψηφίων

Μια μάσκα δυαδικών ψηφίων είναι ένα δυαδικό πρότυπο (bit pattern) που χρησιμοποιείται για την επιλογή
ή την κατάργηση επιλογής συγκεκριμένων δυαδικών ψηφίων σε ακεραίους. Στην πράξη εφαρμόζονται τελεστές bitwise με τελεστέους την τιμή που επιθυμούμε να τροποποιήσουμε και τη μάσκα. Με αυτόν τον τρόπο μπορούμε να ορίσουμε ότι συγκεκριμένα bits θα λάβουν τιμή 1 ή τιμή 0 ή θα εναλλάξουν την τιμή τους.

```{.c title="Κώδικας 2.15: ch2_p15.c - παραδείγματα ελέγχου τιμής και ανάθεσης τιμής σε συγκεκριμένα ψηφία δυαδικών αριθμών." linenums="1"}
--8<-- "src/ch2_p15.c"
```

Το παράδειγμα του κώδικα 2.15 περιλαμβάνει ορισμό της συνάρτησης <span class="p-style">print_binary()</span> που δέχεται ως όρισμα έναν μη προσημασμένο ακέραιο αριθμό και τον εμφανίζει ως δυαδικό αριθμό 32 ψηφίων. Καθώς στις συναρτήσεις θα αναφερθούμε στο Κεφάλαιο 4, θα θεωρήσουμε προς το παρόν τη συγκεκριμένη συνάρτηση ως ένα «μαύρο κουτί» που απλά κάνει την εργασία που επιθυμούμε. Η εκτέλεση του προγράμματος δίνει τα ακόλουθα αποτελέσματα.

```
00000000000000000000000000000000
00000000000000000000000000001011
Flag B is set.
00000000000000000000000000001010
00000000000000000000000000001110
Flag B, and flag C are set.
```
Οι δυνατότητες των τελεστών δυαδικών ψηφίων είναι πάρα πολλές για να αναπτυχθούν εδώ. Δεκάδες παραδείγματα έξυπνης εφαρμογής τους υπάρχουν στο [^2].

### 2.6.6 Τελεστές μετατροπής τύπων

Η C πραγματοποιεί αυτόματες μετατροπές τύπων όταν τελεστέοι διαφορετικών τύπων συμμετέχουν σε μια έκφραση ή σε μια ανάθεση τιμής. Οι μετατροπές αυτές γίνονται βάσει κανόνων της γλώσσας όπως οι ακόλουθοι.

1. Αν συμμετέχουν σε μια αριθμητική πράξη διαφορετικοί τύποι, τότε μετατρέπονται οι μικρότεροι τύποι σε μεγαλύτερους (π.χ. int σε float) και μετά γίνεται η πράξη.
2. Αν ανατίθεται μια τιμή ενός τύπου σε μεταβλητή ενός άλλου τύπου, τότε ο μεταγλωττιστής μετατρέπει την τιμή στον τύπο της μεταβλητής μόνο αν δεν προκαλείται απώλεια δεδομένων κατά τη μετατροπή. Για παράδειγμα, μπορεί να ανατεθεί μια int τιμή σε μια μεταβλητή τύπου float χωρίς πρόβλημα.  


Μετατροπές τύπων όπως αυτές που αναφέρθηκαν είναι γνωστές ως υπονοούμενες μετατροπές τύπων (implicit type conversions ή coercions). Από την άλλη μεριά, υπάρχουν οι ρητές μετατροπές τύπων (explicit type conversions) που είναι γνωστές και ως casts. Αυτό επιτυγχάνεται γράφοντας (τύπος) έκφραση έτσι ώστε η έκφραση να μετατραπεί στον ζητούμενο τύπο. Ένα παράδειγμα “casting” δίνεται στον κώδικα 2.16.

```{.c title="Κώδικας 2.16: ch2_p16.c - μετατροπή ακεραίων τιμών σε πραγματικές τιμές." linenums="1"}
--8<-- "src/ch2_p16.c"
```
Ακολουθεί το αποτέλεσμα της εκτέλεσης του κώδικα:

```
2.0
2.5
2.5
```
### 2.6.7 Άλλοι τελεστές

Η C διαθέτει επιπλέον τελεστές όπως ο <span class="p-style">sizeof</span> που ήδη χρησιμοποιήσαμε στο παράδειγμα ch2_p1.c, ο τελεστής διεύθυνσης μνήμης <span class="p-style">&</span>, ο τριαδικός τελεστής <span class="p-style">?:</span> και άλλους όπως τον τελεστή τελεία . και τον τελεστή βελάκι <span class="p-style">‐></span> που θα δούμε στα Κεφάλαια 6 και 7. Στη συνέχεια δίνεται μια σύντομη περιγραφή του <span class="p-style">sizeof</span>, του & ως τελεστή διεύθυνσης μνήμης και του ?:.  

<i>Ο τελεστής <span class="p-style">sizeof</span></i> Ο τελεστής <span class="p-style">sizeof</span> χρησιμοποιείται για να ληφθεί το μέγεθος σε bytes ενός τύπου δεδομένων, μιας μεταβλητής ή μιας έκφρασης. Ο υπολογισμός αυτός γίνεται κατά τον χρόνο μεταγλώττισης και
όχι κατά την εκτέλεση. Το αποτέλεσμα που επιστρέφει ο <span class="p-style">sizeof</span> είναι ένας μη προσημασμένος ακέραιος τύπου <span class="p-style">size_t</span>. Ο κώδικας 2.17 δείχνει ότι ο τελεστής μπορεί να εφαρμοστεί και σε εκφράσεις. Στην περίπτωση των μεταβλητών ο τελεστής <span class="p-style">sizeof</span> μπορεί να χρησιμοποιηθεί και χωρίς τις παρενθέσεις.

```{.c title="Κώδικας 2.17: ch2_p17.c - παράδειγμα χρήσης του τελεστή sizeof." linenums="1"}
--8<-- "src/ch2_p17.c"
```
Η κλήση της συνάρτησης <span class="p-style">printf()</span> στις γραμμές 7 και 8 θα εμφανίσει ότι το μέγεθος του αποτελέσματος της έκφρασης <span class="p-style">x + 1.5</span> είναι 8 bytes. Αυτό συμβαίνει διότι για να υπολογιστεί η έκφραση θα πρέπει να μετατραπεί η τιμή της ακέραιας μεταβλητής <span class="p-style">x</span> σε <span class="p-style">double</span> και το αποτέλεσμα θα είναι τύπου <span class="p-style">double</span>, που καταλαμβάνει στη μνήμη 8 bytes.

```
The size of data type int is 4 bytes
The size of variable x is 4 bytes
The size of the value of the expression x + 1.5 is 8 bytes
```
<i> Ο τελεστής διεύθυνσης μνήμης <span class="p-style">&</span></i> Ο τελεστής <span class="p-style">&</span> αναφέρθηκε ήδη ως bitwise and, αλλά έχει διαφορετικό ρόλο αν τοποθετηθεί πριν από από μια μεταβλητή οπότε επιστρέφει τη διεύθυνση μνήμης της μεταβλητής.
Δείτε το ακόλουθο παράδειγμα (κώδικας 2.18):

```{.c title="Κώδικας 2.18: ch2_p18.c - παράδειγμα χρήσης του τελεστή διεύθυνση μνήμης." linenums="1"}
--8<-- "src/ch2_p18.c"
```
Ακολουθεί ένα παράδειγμα εκτέλεσης του κώδικα:

```
Variable x has value 42 and is at address 0000006EDF3FFB78
Variable y has value 1729 and is at address 0000006EDF3FFB74
Space in bytes between memory locations of x and y is 4
```

<i>Ο τριαδικός τελεστής ?:</i> Ο τριαδικός τελεστής επιτρέπει τη συγγραφή εκφράσεων επιλογής με την ακόλουθη συνοπτική σύνταξη:

```
(συνθήκη) ? (έκφραση_αν_είναι_αληθής) : (έκφραση_αν_είναι_ψευδής)
```
Η συνθήκη είναι μια λογική έκφραση που μπορεί να αποτιμηθεί είτε αληθής είτε ψευδής. Αν η συνθήκη είναι αληθής, τότε αποτιμάται η έκφραση μετά το <span class="p-style">?</span> και επιστρέφει ως αποτέλεσμα του τριαδικού τελεστή. Αν η συνθήκη είναι ψευδής, τότε αποτιμάται η έκφραση μετά το <span class="p-style">:</span> και επιστρέφει αυτή ως αποτέλεσμα του τελεστή. Πρόκειται για έναν σύντομο τρόπο γραφής κώδικα που θα μπορούσε να γραφεί με την εντολή <span class="p-style">if</span> που θα δούμε στο επόμενο κεφάλαιο. Ένα παράδειγμα χρήσης του τριαδικού τελεστή που εντοπίζει τον μεγαλύτερο από δύο αριθμούς φαίνεται στη συνέχεια στον κώδικα 2.19

```{.c title="Κώδικας 2.19: ch2_p19.c - παράδειγμα χρήσης του τριαδικού τελεστή." linenums="1"}
--8<-- "src/ch2_p19.c"
```

Ακολουθούν τα αποτελέσματα εκτέλεσης.

```
num1=10, num2=7, max=10
```

## 2.7 Προτεραιότητα τελεστών

Στη C οι τελεστές έχουν προτεραιότητες που καθορίζουν τη σειρά αποτίμησης εκφράσεων που περιέχουν διάφορους τελεστές. Πέντε κύρια σημεία σχετικά με την προτεραιότητα των τελεστών στη C είναι τα ακόλουθα:

1. Οι εκφράσεις σε παρενθέσεις εκτελούνται πρώτες. Συνεπώς, κάνοντας χρήση παρενθέσεων μπορεί να
παρακαμφθεί η σειρά πράξεων που επιβάλλει η προτεραιότητα των τελεστών.
2. Για τους αριθμητικούς τελεστές ισχύει η γνωστή από τα μαθηματικά σειρά αποτίμησης. Για παράδειγμα
ο τελεστής <span class="p-style">*</span> έχει μεγαλύτερη προτεραιότητα από τον τελεστή <span class="p-style">+</span>.
3. Οι μοναδιαίοι τελεστές (π.χ. <span class="p-style">++</span>, <span class="p-style">!</span>) έχουν υψηλότερη προτεραιότητα από τους δυαδικούς τελεστές.
4. Οι τελεστής ανάθεσης <span class="p-style">=</span> (καθώς και οι τελεστές πράξης ανάθεσης όπως ο <span class="p-style">+=</span>) έχουν μικρότερη προτεραιότητα από σχεδόν όλους τους άλλους τελεστές. Αποτιμώνται μετά την αποτίμηση της έκφρασης που βρίσκεται στο δεξί μέρος του τελεστή ανάθεσης.
5. Τελεστές με την ίδια προτεραιότητα εκτελούνται βάσει προσεταιριστικότητας του τελεστή. Για παράδειγμα τελεστές όπως ο <span class="p-style">+</span>,<span class="p-style">‐</span>,<span class="p-style">*</span> και <span class="p-style">/</span> έχουν προσεταιριστικότητα από αριστερά προς τα δεξιά, οπότε μια πράξη όπως η 10 ‐ 4 + 3 θα επιστρέψει το σωστό αποτέλεσμα 9 και όχι το 3 που θα προέκυπτε αν το 4 + 3 γινόταν πρώτο. Παράδειγμα τελεστή που έχει προσεταιριστικότητα από δεξιά προς τα αριστερά είναι ο τελεστής ανάθεσης <span class="p-style">=</span>. Ωστόσο, αξίζει να σημειωθεί ότι η πλειονότητα των τελεστών έχει προσεταιριστικότητα από αριστερά προς τα δεξιά.  

Αναλυτικές πληροφορίες για την προτεραιότητα και την προσεταιριστικότητα των τελεστών στη C μπορούν να εντοπιστούν στο [^3].

## 2.8 Κύκλος μεταγλώττισης, σύνδεσης και εκτέλεσης

Η μεταγλώττιση και σύνδεση μετατρέπει τον κώδικα C που είναι σε αναγνώσιμη από τον άνθρωπο μορφή σε δυαδική μορφή που ο υπολογιστής είναι σε θέση να εκτελέσει. Η διαδικασία αυτή που συχνά αναφέρεται ως απλά μεταγλώττιση, αποτελείται από τα ακόλουθα στάδια όπου η έξοδος κάθε σταδίου αποτελεί είσοδο για το επόμενο στάδιο.

1. Προεπεξεργασία
2. Μεταγλώττιση
3. Συμβολομετάφραση
4. Σύνδεση  

Για την επίδειξη της μεταγλώττισης θα χρησιμοποιηθεί το ακόλουθο παράδειγμα πηγαίου κώδικα (κώδικας 2.20).

```{.c title="Κώδικας 2.20: ch2_p20.c - ένα απλό πρόγραμμα που θα χρησιμοποιηθεί για μεταγλώττιση" linenums="1"}
--8<-- "src/ch2_p20.c"
```

Όπως είδαμε και στο προηγούμενο κεφάλαιο, η μεταγλώττιση του προγράμματος μπορεί να γίνει με την ακόλουθη εντολή.

```
$ gcc ‐o ch2_p20 ch2_p20.c ‐lm
```

Στο παρασκήνιο εκτελούνται και τα 4 στάδια μεταγλώττισης και σύνδεσης και παράγεται το εκτελέσιμο αρχείο <span class="p-style">ch2_p20</span>. Ο διακόπτης <span class="p-style">‐o</span> ακολουθείται από το όνομα του εκτελέσιμου αρχείου, ενώ στο συγκεκριμένο παράδειγμα υπάρχει επιπλέον και ο διακόπτης <span class="p-style">‐lm</span> που υποδηλώνει ότι ήδη μεταγλωττισμένες εκδόσεις συναρτήσεων όπως στο παράδειγμα αυτό η <span class="p-style">sqrt()</span> (τετραγωνική ρίζα) θα ληφθούν από κάποιο αρχείο βιβλιοθήκης (π.χ. <span class="p-style">libm.a</span> ή <span class="p-style">libm.so</span> για Linux) και θα συμπληρώσουν τον δυαδικό κώδικα που θα αποτελέσει το εκτελέσιμο.
Η εκτέλεση του προγράμματος θα εμφανίσει την τετραγωνική ρίζα του αριθμού 2.

```
$ ./ch2_p20
The square root of 2.00 is 1.41421356
```
Στη συνέχεια θα παρουσιαστούν τα στάδια μεταγλώττισης και το αποτέλεσμα που παράγει το κάθε στάδιο, όπως φαίνεται και στο Σχήμα 2.1.

``` mermaid
graph TD
    A["πηγαίος κώδικας (*.c, *.h)"] -->|Μεταγλώττιση και σύνδεση| B

    subgraph " "
        B["προεπεξεργασία (gcc -E)"]
        B -->|"*.i"| C["μεταγλώττιση (gcc -c)"]
        C -->|"συμβολικός κώδικας (*.s)"| D["συμβολομετάφραση (as)"]
        D -->|"κώδικας αντικειμένου (*.o)"| E["σύνδεση (ld)"]
    end

    E -->|"εκτελέσιμο"| F[" "]
    G["βιβλιοθήκες"] --> E

```

<div style="text-align: center;"><b>Σχήμα 2.1:</b><i> Στάδια μεταγλώττισης και σύνδεσης.</i></div>

<i>1. Προεπεξεργασία</i> Η προεπεξεργασία προηγείται της πραγματικής μεταγλώττισης. Στο στάδιο αυτό αρχικά αφαιρούνται τυχόν σχόλια και στη συνέχεια ο προεπεξεργαστής ερμηνεύει οδηγίες όπως η <span class="p-style">#include</span> και η <span class="p-style">#define</span> έτσι ώστε να παραχθεί μια νέα μορφή κώδικα, κατάλληλη για τον μεταγλωττιστή. Για να απομονωθεί το στάδιο της προεπεξεργασίας μπορεί να χρησιμοποιηθεί ο διακόπτης ‐E όπως στη συνέχεια:

```
$ gcc ‐o ch2_p20.i ch2_p20.c ‐E
```
Το αρχείο ch2_p20.i που προκύπτει είναι πολύ μεγαλύτερο σε σχέση με το αρχείο πηγαίου κώδικα (1661 γραμμές κώδικα για το συγκεκριμένο παράδειγμα). Ένα απόσπασμα του ch2_p20.i που δείχνει την αρχή και το τέλος του φαίνεται στη συνέχεια:

```
# 0 "ch2_p20.c"
# 0 "<built‐in>"
# 0 "<command ‐line>"
# 1 "/usr/include/stdc‐predef.h" 1 3 4
...
# 4 "ch2_p20.c"
int main() {
    double x = 2.0;
    double irrational = sqrt(x);
    printf("The square root of %.2f is %.8f\n", x, irrational);
    return 0;
}
```

Η χρήση του διακόπτη ‐E προκαλεί την κλήση του προγράμματος <span class="p-style">cpp</span> (C PreProcessor), οπότε το ίδιο αποτέλεσμα θα είχε προκύψει και με την εντολή:

```
$ cpp ‐o ch2_p20.i ch2_p20.c
```

<i>2. Μεταγλώττιση</i> Στο στάδιο της μεταγλώττισης μετατρέπονται τα περιεχόμενα του <span class="p-style">.i</span> αρχείου σε συμβολικό κώδικα (assembly), δηλαδή κώδικα χαμηλού επιπέδου. Στο στάδιο αυτό εντοπίζονται τυχόν συντακτικά σφάλματα (syntax errors) και παράγονται μηνύματα λαθών καθώς και προειδοποιήσεις (warnings). Η εντολή που ακολουθεί χρησιμοποιεί τον διακόπτη <span class="p-style">‐S</span> και παράγει το αρχείο συμβολικού κώδικα <span class="p-style">ch2_p20.s</span>.

```
$ gcc ‐o ch2_p20 ‐S ch2_p20.i
```
Ο συμβολικός κώδικας που δημιουργείται εξαρτάται από το σύστημα για τον οποίο δημιουργείται. Συνεπώς θα είναι διαφορετικός για τον ίδιο κώδικα C ακόμα και αν χρησιμοποιηθεί ο ίδιος μεταγλωττιστής (π.χ. gcc) σε διαφορετικά συστήματα (π.χ. Linux ή Windows ή OSX λειτουργικό σύστημα, x86 ή x86-64 ή ARM αρχιτεκτονική CPU). Η κατανόηση του κώδικα assembly είναι χρήσιμη δεξιότητα καθώς βοηθά στην κατανόηση της απόδοσης των προγραμμάτων και σε ορισμένες περιπτώσεις επιτρέπει την περαιτέρω εκμετάλλευση των δυνατοτήτων του υλικού.  

Μια ενδιαφέρουσα σελίδα που επιτρέπει τη δημιουργία συμβολικού κώδικα για πολλά και διαφορετικά συστήματα και στη συνέχεια τον πειραματισμό με τον κώδικα που δημιουργείται είναι η Complexity Explorer(1) από τον Matt Godbolt.
{ .annotate }

1.  <a href="https://godbolt.org/" target="_blank">https://godbolt.org/</a>

```{.asm title="Κώδικας 2.21: Συμβολικός κώδικας για το ch2_p20.c σε σύστημα x86-64 gcc 13.1." linenums="1"}
--8<-- "src/ch2_p21.asm"
```

<i>3. Συμβολομετάφραση </i> Ο κώδικας assembly μετατρέπεται σε εντολές μηχανής από τον συμβολομεταφραστή (assembler). Οι εντολές συμβολικού κώδικα μετατρέπονται σε δυαδικό κώδικα που είναι γνωστός ως κώδικας αντικείμενο (object code). Με την ακόλουθη εντολή παράγεται το αρχείο αντικείμενο που έχει επέκταση <span class="p-style">.o</span>. Το πρόγραμμα που αναλαμβάνει τη διαδικασία είναι το <span class="p-style">as</span>.

```
$ as ‐o ch2_p20.o ch2_p20.s
```

<i>4. Σύνδεση </i> Στη σύνδεση συνδέεται κώδικας που υπάρχει σε βιβλιοθήκες με το πρόγραμμά μας. Το πρόγραμμα μπορεί να αποτελείται από επιμέρους αρχεία πηγαίου κώδικα, οπότε η σύνδεση αναλαμβάνει να συνδυάσει τα επιμέρους αρχεία σε ένα τελικό εκτελέσιμο. Το θέμα αυτό θα αναλυθεί στο Κεφάλαιο 13 που εξετάζει το θέμα της διαμέρισης κώδικα. Το πρόγραμμα που αναλαμβάνει τη σύνδεση είναι το ld, αλλά η αλληλεπίδραση μαζί του είναι ευκολότερη μέσω του <span class="p-style">gcc</span> όπως στο ακόλουθο παράδειγμα που χρησιμοποιεί το αρχείο αντικείμενο για να παράξει το τελικό εκτελέσιμο <span class="p-style">ch2_p20</span>.

```
$ gcc ‐o ch2_p20 ch2_p20.o
```

Ο μεταγλωττιστής gcc δίνει τη δυνατότητα δημιουργίας όλων των ενδιάμεσων αρχείων που παράγονται από τα στάδια μεταγλώττισης χρησιμοποιώντας τον διακόπτη <span class="p-style">‐save‐temps</span>. Έτσι με την ακόλουθη εντολή δημιουργούνται και τα 4 αρχεία που πριν δημιουργήθηκαν με ξεχωριστές εντολές.

```
$ gcc ‐o ch2_p20 ‐save‐temps ch2_p20.c 
```
Τα αρχεία που δημιουργούνται είναι τα <span class="p-style">ch2_p20.i</span>, <span class="p-style">ch2_p20.s</span>, <span class="p-style">ch2_p20.o</span> και <span class="p-style">ch2_p20</span>.


## 2.9 Ασκήσεις

***Άσκηση 1***  
Γράψτε ένα πρόγραμμα που να δέχεται ένα χρονικό διάστημα σε δευτερόλεπτα και να εμφανίζει το χρονικό διάστημα στη μορφή ΩΩ:ΛΛ:ΔΔ όπου ΩΩ είναι οι ώρες, ΛΛ είναι τα λεπτά και ΔΔ είναι τα δευτερόλεπτα (π.χ. για είσοδο 64326 να εμφανίζει 17:52:06).

??? tip "Λύση άσκησης 1"
    ```{.c linenums="1"}
    --8<-- "src/ch2_e1.c"
    ```

***Άσκηση 2***  
Γράψτε πρόγραμμα που να δημιουργεί έναν μη προσημασμένο ακέραιο <span class="p-style">(unsigned int)</span> με όλα τα δυαδικά του ψηφία να έχουν την τιμή 1. Εκτυπώστε την τιμή του στο δεκαδικό σύστημα και επιβεβαιώστε ότι η τιμή αυτή ταυτίζεται με τη σταθερά <span class="p-style">UINT_MAX</span> από το <span class="p-style">limits.h</span>.  

??? tip "Λύση άσκησης 2"
    ```{.c linenums="1"}
    --8<-- "src/ch2_e2.c"
    ```

***Άσκηση 3***  
Eντοπίστε τις διαφορές των προσδιοριστών μορφοποίησης <span class="p-style">%i</span> και <span class="p-style">%d</span> κατά τη χρήση τους στις <span class="p-style">printf()</span> και <span class="p-style">scanf()</span>.  

??? tip "Λύση άσκησης 3"
    ```{.c linenums="1"}
    --8<-- "src/ch2_e3.c"
    ```

***Άσκηση 4***  
Γράψτε ένα απλό πρόγραμμα που να δημιουργεί μια μεταβλητή τύπου int και μια μεταβλητή τύπου <span class="p-style">unsigned int</span>. Αναθέστε και στις δύο από το <span class="p-style">limits.h</span> τις μεγαλύτερες τιμές που μπορούν να λάβουν (<span class="p-style">ΜΑΧ_ΙΝΤ</span> και <span class="p-style">UINT_MAX</span> αντίστοιχα) και εκτυπώστε τις τιμές αυτές. Αυξήστε κατά ένα τις τιμές
και των δύο μεταβλητών και εκτυπώστε τις τιμές εκ νέου. Τι παρατηρείτε;

??? tip "Λύση άσκησης 4"
    ```{.c linenums="1"}
    --8<-- "src/ch2_e4.c"
    ```

***Άσκηση 5***  
Εκτυπώστε τις τιμές των εκφράσεων 0.1 + 0.2, 0.1 + 0.3, 0.1 + 0.2 == 0.3, 0.1 + 0.3 == 0.4. Τι παρατηρείτε; Αναζητήστε τους λόγους της «περίεργης» συμπεριφοράς στο [^4].

??? tip "Λύση άσκησης 5"
    ```{.c linenums="1"}
    --8<-- "src/ch2_e5.c"
    ```



[^1]: Don Colton. <i>Secrets of ”printf”.</i> <a href="https://inst.eecs.berkeley.edu/~cs61c/fa19/hw/hw2/printf_colton.pdf" target="_blank">https://inst.eecs.berkeley.edu/~cs61c/fa19/hw/hw2/printf_colton.pdf</a> Accessed: 2023-06-01. 2015

[^2]: Sean Eron Anderson. <i>Bit Twiddling Hacks.</i> <a href="http://graphics.stanford.edu/~seander/bithacks.html" target="_blank">http://graphics.stanford.edu/~seander/bithacks.html</a>. Accessed: 2023-06-01

[^3]: <i>C Operator Precedence.</i> <a href="https://en.cppreference.com/w/c/language/operator_precedence" target="_blank">https://en.cppreference.com/w/c/language/operator_precedence</a>. Accessed: 2023-06-01.

[^4]: Sean Eron Anderson. <i>Floating Point Numbers. Why floating-point numbers are needed?</i> <a href="https://floating-point-gui.de/formats/fp/" target="_blank">https://floating‐point‐gui.de/formats/fp/</a>. Accessed: 2023-06-01.