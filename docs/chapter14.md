# 14. Ανάπτυξη οδηγούμενη από ελέγχους

<i>Σύνοψη</i> Έλεγχος μονάδας, βιβλιοθήκες ελέγχου μονάδας, η βιβλιοθήκη Unity, συγγραφή και εκτέλεση
ελέγχων μονάδας με τη Unity, ανάπτυξη οδηγούμενη από ελέγχους.  

<i>Προαπαιτούμενη γνώση</i> Τύποι δεδομένων, είσοδος/έξοδος, δομές επιλογής και επανάληψης, συναρτήσεις, πίνακες, δείκτες, αλφαριθμητικά, διαμέριση κώδικα.

## 14.1 Έλεγχος μονάδας

Ο έλεγχος λογισμικού (software testing) είναι συνυφασμένος με την ανάπτυξη λογισμικού. Πραγματοποιώντας ελέγχους λογισμικού παρέχονται «διαβεβαιώσεις» ότι το λογισμικό λειτουργεί ορθά με βάση καθορισμένες προδιαγραφές, καθώς για δεδομένες εισόδους επιβεβαιώνεται η ορθότητα των παραγόμενων αποτελεσμάτων. Ωστόσο, αν και ο έλεγχος λογισμικού μπορεί να εντοπίσει σφάλματα, δεν μπορεί να εγγυηθεί την απουσία τους.  
Ο έλεγχος μονάδας (unit testing) είναι ένας αυτόματος μηχανισμός που καλεί μια μονάδα του λογισμικού (π.χ. μια συνάρτηση) και επιβεβαιώνει ότι για συγκεκριμένες εισόδους επιστρέφονται τα θεωρούμενα ως ορθά αποτελέσματα. Κάθε μοναδιαίος έλεγχος (unit test) είναι ένα σύντομο τμήμα κώδικα που εξετάζει, σχετικά ανεξάρτητα από τον υπόλοιπο κώδικα, μια μονάδα λογισμικού και επιστρέφει ως αποτέλεσμα την επιτυχία ή την αποτυχία του ελέγχου. Είναι γενικά αποδεκτό ότι οι έλεγχοι μονάδων που γίνονται κατά τη διαδικασία ανάπτυξης του λογισμικού λειτουργούν θετικά ως προς την ποιότητα και τον χρόνο ανάπτυξης του λογισμικού. Αυτό συμβαίνει διότι ορισμένα λάθη εντοπίζονται νωρίς, πριν δημιουργήσουν μεγαλύτερα προβλήματα. Ίσως περισσότερο σημαντικό είναι ότι οι προγραμματιστές συνηθίζουν να σκέφτονται ότι ο κώδικάς τους πρέπει να είναι σε θέση να ικανοποιεί τις προδιαγραφές των ελέγχων, οπότε οδηγούνται σχετικά αυτόματα σε λύσεις με καλύτερα ποιοτικά χαρακτηριστικά. Επιπλέον, πιθανές αλλαγές κώδικα μπορούν αυτόματα να ελέγχονται σχετικά με το εάν «σπάνε» κάπου τον υπάρχοντα κώδικα.

### 14.1.1 Βιβλιοθήκες ελέγχου μονάδας για τη C

Η C μπορεί να υποστηρίξει μοναδιαίους ελέγχους μέσω εξωτερικών βιβλιοθηκών, ενώ ένας απλοϊκός τρόπος υλοποίησης μοναδιαίων ελέγχων μπορεί να εφαρμοστεί με την κλήση της συνάρτησης <span class="p-style">assert()</span> που παρουσιάζεται στο Κεφάλαιο 15. Σε ό,τι αφορά τις εξωτερικές βιβλιοθήκες, υπάρχουν πολλές διαθέσιμες επιλογές και μερικές από τις πλέον διαδεδομένες περιπτώσεις παρουσιάζονται στην ακόλουθη λίστα:

*   Cgreen (1)  
    { .annotate }

    1. <a href="https://cgreen-devs.github.io/cgreen/cgreen-guide-en.html" target="_blank">https://cgreen-devs.github.io/cgreen/cgreen-guide-en.html</a> 

*   Cpputest (1)  
    { .annotate }

    1. <a href="http://cpputest.github.io/" target="_blank">http://cpputest.github.io/</a> 

*   Criterion (1)  
    { .annotate }

    1. <a href="https://github.com/Snaipe/Criterion" target="_blank">https://github.com/Snaipe/Criterion</a> 

*   LCUT (1)  
    { .annotate }

    1. <a href="https://github.com/bigwhite/lcut" target="_blank">https://github.com/bigwhite/lcut</a> 

*   MinUnit (1)  
    { .annotate }

    1. <a href="https://github.com/siu/minunit" target="_blank">https://github.com/siu/minunit</a> 

*   Unity (1)  
    { .annotate }

    1. <a href="http://www.throwtheswitch.org/unity" target="_blank">http://www.throwtheswitch.org/unity</a> 


Στη συνέχεια του κεφαλαίου θα χρησιμοποιηθεί η βιβλιοθήκη Unity λόγω του ότι είναι απλή για βασική χρήση, αλλά διαθέτει και προχωρημένες δυνατότητες που μπορεί κανείς να χρησιμοποιήσει εφόσον επιθυμεί. Επιπλέον, η Unity μπορεί να εγκατασταθεί εύκολα, υποστηρίζει και τα τρία πλέον διαδεδομένα λειτουργικά συστήματα (Windows, Linux, MacOS) και ο κώδικάς της έχει γραφεί εξολοκλήρου σε C σύμφωνα με τα ANSI πρότυπα. Αξίζει να σημειωθεί ότι η Unity χρησιμοποιείται από τη δημοφιλή ιστοσελίδα εκμάθησης και εξάσκησης στον προγραμματισμό <a href="https://exercism.org/" target="_blank">https://exercism.org/</a> σε ό,τι αφορά το C track που προσφέρει, γεγονός που υποδηλώνει ότι πρόκειται για ώριμο λογισμικό. Τέλος, μπορεί να χρησιμοποιηθεί και για έλεγχο κώδικα σε ενσωματωμένα συστήματα (embedded systems). Το βιβλίο [^1] εστιάζει ακριβώς σε αυτό το θέμα χρησιμοποιώντας τη Unity.

## 14.2 Unity

Όπως αναφέρθηκε στην προηγούμενη παράγραφο, η Unity είναι μια βιβλιοθήκη ελέγχων μονάδας για τη C. Στο απλούστερο σενάριο, για να χρησιμοποιηθεί, αρκεί να βρίσκονται τα αρχεία <span class="p-style">unity.c</span>, <span class="p-style">unity.h</span> και <span class="p-style">unity_internals.h</span> σε θέσεις που να είναι γνωστές στον μεταγλωττιστή. Τα αρχεία αυτά μπορούν να μεταφορτωθούν από τη σελίδα της Unity. Αν και η Unity μπορεί να χρησιμοποιηθεί για περαιτέρω αυτοματοποίηση των ελέγχων, σε συνδυασμό με τις βιβλιοθήκες Ceedling και CMock που έχουν αναπτυχθεί επίσης από την ίδια ομάδα (ThrowTheSwitch.org), η περιγραφή και τα παραδείγματα που θα ακολουθήσουν χρησιμοποιούν μόνο τη Unity.  
Η βιβλιοθήκη διαθέτει διαφόρων ειδών assertions, δηλαδή εντολών που επαληθεύουν ότι οι τιμές που υπολογίζονται από τον κώδικα της εφαρμογής είναι οι αναμενόμενες. Υπάρχουν πολλές συναρτήσεις επαλήθευσης τιμών <span class="p-style">TEST_ASSERT</span>. Στη συνέχεια θα γίνει αναφορά στις σημαντικότερες από αυτές ανά ομάδα.

__Επαλήθευση λογικών τιμών.__ Οι συναρτήσεις που ακολουθούν επαληθεύουν την τιμή μιας λογικής συνθήκης (condition).  

* <span class="p-style">TEST_ASSERT_TRUE(condition)</span> - Αν η συνθήκη είναι αληθής τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_FALSE(condition)</span> - Αν η συνθήκη είναι ψευδής τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_NULL(pointer)</span> - Αν ο pointer είναι NULL τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_ΝΟΤ_NULL(pointer)</span> - Αν ο pointer δεν είναι NULL τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.

__Επαλήθευση ακέραιων τιμών.__ Υπάρχουν ξεχωριστές ομάδες συναρτήσεων για επαλήθευση ακεραίων με πρόσημο, ακεραίων χωρίς πρόσημο καθώς και υποστήριξη για διάφορα μεγέθη ακεραίων (8bits, 16bits, 32bits, 64bits).

* <span class="p-style">TEST_ASSERT_EQUAL_INT(expected, actual)</span> - Αν η αναμενόμενη (<span class="p-style">expected</span>) τιμή είναι ίση με την τιμή που υπολογίζεται (<span class="p-style">actual</span>), τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_EQUAL_INT_WITHIN(delta, expected, actual)</span> - Ο έλεγχος επιτυγχάνει αν η <span class="p-style">int</span> τιμή <span class="p-style">actual</span> απέχει το πολύ <span class="p-style">delta</span> από την <span class="p-style">int</span> τιμή <span class="p-style">expected</span>, αλλιώς αποτυγχάνει.

__Επαλήθευση πραγματικών τιμών.__ Υπάρχουν συναρτήσεις για επαλήθευση <span class="p-style">float</span> και <span class="p-style">double</span> αποτελεσμάτων.


* <span class="p-style">TEST_ASSERT_FLOAT(expected, actual)</span> - Αν η αναμενόμενη (<span class="p-style">expected</span>) τιμή είναι ίση με την τιμή που υπολογίζεται (<span class="p-style">actual</span>), τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_DOUBLE(expected, actual)</span> - Αντίστοιχα με την παραπάνω για <span class="p-style">double</span> τιμές όμως.
* <span class="p-style">TEST_ASSERT_FLOAT_WITHIN(delta, expected, actual)</span> - Ο έλεγχος επιτυγχάνει αν η τιμή <span class="p-style">actual</span> απέχει το πολύ <span class="p-style">delta</span> από την τιμή <span class="p-style">expected</span>, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_DOUBLE_WITHIN(delta, expected, actual)</span> - Αντίστοιχα με την παραπάνω για <span class="p-style">double</span> τιμές όμως.  

__Επαλήθευση τιμών δεικτών (και λεκτικών).__

* <span class="p-style">TEST_ASSERT_EQUAL_PTR(expected, actual)</span> - Αν η <span class="p-style">expected</span> τιμή δείκτη είναι ίση με την τιμή δείκτη <span class="p-style">actual</span>, τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_EQUAL_STRING(expected, actual)</span> - Αν το λεκτικό <span class="p-style">expected</span> είναι ίσο χαρακτήρα προς χαρακτήρα με το λεκτικό <span class="p-style">actual</span> και τα δύο λεκτικά τερματίζονται ορθά με τον <span class="p-style">NULL</span> χαρακτήρα τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.
* <span class="p-style">TEST_ASSERT_EQUAL_STRING_LEN(expected, actual, len)</span> - Αν το λεκτικό <span class="p-style">expected</span> είναι ίσο χαρακτήρα προς χαρακτήρα μέχρι το μήκος <span class="p-style">len</span>, τότε ο έλεγχος επιτυγχάνει, αλλιώς αποτυγχάνει.

Εκτός από τις ανωτέρω ομάδες συναρτήσεων ελέγχου, η Unity υποστηρίζει επαλήθευση δεκαεξαδικών τιμών, επαλήθευση bits, επαλήθευση πινάκων και επαλήθευση δομών και μνήμης. Για κάθε συνάρτηση υπάρχει και μια παραλλαγή της όπου το αναγνωριστικό της τελειώνει με <span class="p-style">_MESSAGE</span> και δέχεται μια επιπλέον, τελευταία στη σειρά παράμετρο, που αντιστοιχεί στο μήνυμα που επιθυμούμε να εμφανίζεται, όταν ο έλεγχος θα αποτυγχάνει. Για παράδειγμα, για την <span class="p-style">TEST_ASSERT_EQUAL_INT64(expected, actual)</span> η αντίστοιχη συνάρτηση με προσαρμοσμένο μήνυμα είναι η <span class="p-style">TEST_ASSERT_EQUAL_INT64_MESSAGE(expected, actual, message)</span>.  
Μια άλλη χρήσιμη συνάρτηση είναι η <span class="p-style">TEST_FAIL()</span>, που προκαλεί την άμεση αποτυχία ενός ελέγχου. Κάτι τέτοιο βρίσκει εφαρμογή για παράδειγμα όταν ένας έλεγχος αφορά κώδικα που δεν έχει ακόμα υλοποιηθεί. Καλώντας τη συνάρτηση <span class="p-style">TEST_FAIL()</span> ο έλεγχος αποτυγχάνει και συνεπώς εμφανίζεται στη λίστα ελέγχων που πρέπει να επιδιορθωθούν στη συνέχεια. Με αυτόν τον τρόπο ο προγραμματιστής πληροφορείται για τον κώδικα που πρέπει να υλοποιηθεί κατά προτεραιότητα.  
Επίσης, η Unity δίνει τη δυνατότητα να αγνοηθούν ένας ή περισσότεροι έλεγχοι με χρήση της συνάρτησης <span class="p-style">TEST_IGNORE()</span>. Η προσθήκη μιας κλήσης της <span class="p-style">TEST_IGNORE()</span> πάνω από κλήσεις <span class="p-style">TEST_ASSERT</span> οδηγεί στο να αγνοηθούν κατά την εκτέλεση των ελέγχων οι κλήσεις των <span class="p-style">TEST_ASSERT</span>. Αυτό μπορεί να είναι χρήσιμο όταν επιθυμούμε να ασχοληθούμε σταδιακά με την υλοποίηση κώδικα που «περνά» ένα προς ένα τα <span class="p-style">TEST_ASSERT</span>. Τοποθετούμε το <span class="p-style">TEST_IGNORE()</span> αμέσως μετά από το πρώτο <span class="p-style">TEST_ASSERT</span>, το οποίο αρχικά αποτυγχάνει, υλοποιούμε τον κώδικα που το κάνει να επιτυγχάνει και μόλις συμβεί αυτό μεταφέρουμε το <span class="p-style">TEST_IGNORE()</span> κάτω από το επόμενο TEST_ASSERT και επαναλαμβάνουμε τη διαδικασία μέχρι
η <span class="p-style">TEST_IGNORE()</span> να βρεθεί κάτω από το τελευταίο <span class="p-style">TEST_ASSERT</span>. Αυτή μάλιστα είναι η διαδικασία που χρησιμοποιεί η σελίδα <a href="https://exercism.org/" target="_blank">https://exercism.org/</a> για τον έλεγχο της ορθότητας των λύσεων που υποβάλλουν οι χρήστες του.

### 14.2.1 Πρακτική χρήση της Unity

Συνήθως, δημιουργείται ένα αρχείο test για κάθε C module που επιθυμούμε να ελέγξουμε στο οποίο γίνεται <span class="p-style">include</span> το <span class="p-style">utility.h</span> και το αρχείο επικεφαλίδας του module. Το αρχείο test μπορεί να περιέχει τις συναρτήσεις <span class="p-style">setUp()</span> και <span class="p-style">tearDown()</span>. Στην πρώτη συνάρτηση συμπεριλαμβάνουμε οτιδήποτε επιθυμούμε να εκτελεστεί πριν κάθε <span class="p-style">test</span> και στη δεύτερη οτιδήποτε επιθυμούμε να εκτελεστεί μετά. Το αρχείο test συμπληρώνεται με συναρτήσεις που ξεκινούν είτε με τη λέξη <span class="p-style">test_</span> είτε με τη λέξη <span class="p-style">spec_</span>, αν και αυτό είναι απλά μια σύμβαση. Όλες οι συναρτήσεις που αναφέρθηκαν δεν δέχονται ορίσματα και δεν επιστρέφουν κάποια τιμή. Στο τέλος του αρχείου test συμπληρώνεται η συνάρτηση <span class="p-style">main()</span> που καλεί αρχικά τη συνάρτηση <span class="p-style">UNITY_BEGIN()</span>, μετά την <span class="p-style">RUN_TEST</span> για κάθε test συνάρτηση, και τελικά τη συνάρτηση <span class="p-style">UNITY_END()</span>.  

### 14.2.2 Παράδειγμα χρήσης της Unity

Η λειτουργία της Unity θα επιδειχθεί στη συνέχεια μέσω ενός υποθετικού σεναρίου στο οποίο σταδιακά θα συμπληρωθεί ο κώδικας συναρτήσεων που θα ελέγχουν ότι ένα συνθηματικό ικανοποιεί τους ακόλουθους κανόνες:

1. Nα έχει μήκος από 5 μέχρι και 20 χαρακτήρες.
2. Να περιέχει τουλάχιστον 1 ψηφίο.
3. Να περιέχει τουλάχιστον 1 πεζό γράμμα της αγγλικής αλφαβήτου.
4. Να περιέχει τουλάχιστον 1 κεφαλαίο γράμμα της αγγλικής αλφαβήτου.  


Ειδικότερα, ζητείται για τις συναρτήσεις που δηλώνονται στο <span class="p-style">ch14_p1.h</span> (κώδικας 14.1) να συμπληρωθεί ο κώδικάς τους στο <span class="p-style">ch14_p1.c</span> (κώδικας 14.2) έτσι ώστε να επαληθεύονται όλοι οι έλεγχοι που βρίσκονται στο <span class="p-style">ch14_p1_test.c</span> (κώδικας 14.3). Παρατηρήστε ότι στην παρούσα φάση το <span class="p-style">ch14_p1_test.c</span> περιλαμβάνει μόνο stubs συναρτήσεων. Ένα stub συνάρτησης είναι μια συνάρτηση η οποία μπορεί να κληθεί χωρίς να προκαλείται σφάλμα, αλλά η ίδια δεν επιτελεί κάποιο έργο. Ο σκοπός της είναι να λειτουργήσει ως «κράτηση θέσης» (placeholder) στην οποία, σε κάποια μετέπειτα φάση, θα συμπληρωθεί κώδικας που θα παρέχει την επιθυμητή λειτουργικότητα.

```{.c title="Κώδικας 14.1: ch14_p1.h - αρχείο επικεφαλίδας με συναρτήσεις που πρέπει να υλοποιηθούν." linenums="1"}
--8<-- "src/ch14_p1.h"
```

```{.c title="Κώδικας 14.2: ch14_p1.c - αρχείο πηγαίου κώδικα με stubs 4 συναρτήσεων που θα υλοποιηθούν στη συνέχεια." linenums="1"}
--8<-- "src/ch14_p1.c"
```
```{.c title="Κώδικας 14.3: ch14_p1_test.c - μοναδιαίοι έλεγχοι με το Unity." linenums="1"}
--8<-- "src/ch14_p1_test.c"
```

Η μεταγλώττιση και εκτέλεση των ελέγχων γίνεται ως εξής:

```
$ gcc unity.c ch14_p1.c ch14_p1_test.c ‐o ch14_p1
$ ./ch14_p1
ch14_p1_test.c:9:test_has_size_ok:FAIL: Expected TRUE Was FALSE
ch14_p1_test.c:50:test_has_size_ok:IGNORE: Not implemented yet
```

Ο έλεγχος αποτυγχάνει στη γραμμή 9 του <span class="p-style">ch14_p1_test.c</span> καθώς η αναμενόμενη τιμή ήταν <span class="p-style">true</span>, αλλά επιστράφηκε η τιμή <span class="p-style">false</span>. Αυτό συνέβη διότι ο κώδικας της συνάρτησης <span class="p-style">has_size_ok()</span> στο <span class="p-style">ch14_p1.c</span> δεν έχει συμπληρωθεί επί της ουσίας, αλλά απλά επιστρέφει πάντα την τιμή <span class="p-style">false</span>. Το δεύτερο μήνυμα προκαλείται από την κλήση της <span class="p-style">TEST_IGNORE_MESSAGE</span> η οποία εμφανίζει το μήνυμα που δέχεται ως όρισμα και αποτρέπει την εκτέλεση των ελέγχων που ακολουθούν. Συνεπώς, το επόμενο βήμα μας θα πρέπει να είναι η ορθή υλοποίηση της συνάρτησης <span class="p-style">has_size_ok()</span>. Αυτό συμβαίνει με τον ακόλουθο κώδικα (κώδικας 14.4) να αντικαθιστά τον κώδικα της συνάρτησης <span class="p-style">has_ok_size()</span> στο <span class="p-style">ch14_p1.c</span>.

```{.c title="Κώδικας 14.4: Ο κώδικας της has_ok_size() που θα αντικαταστήσει το stub της συνάρτησης που αρχικά υπάρχει στο ch14_p1.c" }
--8<-- "src/ch14_p1_has_ok_size.c"
```

Τώρα, η μεταγλώττιση και εκτέλεση των ελέγχων θα επιστρέψει τα ακόλουθα:

```
$ gcc unity.c ch14_p1.c ch14_p1_test.c ‐o ch14_p1
$ ./ch14_p1
ch14_p1_test.c:49:test_has_size_ok:PASS
ch14_p1_test.c:50:test_has_size_ok:IGNORE: Not implemented yet
```

Μεταφέροντας την κλήση της συνάρτησης <span class="p-style">TEST_IGNORE_MESSAGE()</span> κάτω από την επόμενη κλήση συνάρτησης ελέγχου, την <span class="p-style">RUN_TEST(test_has_digit)</span>, λαμβάνουμε το ακόλουθο μήνυμα κατά τη μεταγλώττιση και εκτέλεση.

```
$ gcc unity.c ch14_p1.c ch14_p1_test.c ‐o ch14_p1
$ ./ch14_p1
ch14_p1_test.c:49:test_has_size_ok:PASS
ch14_p1_test.c:18:test_has_digit:FAIL: Expected TRUE Was FALSE
ch14_p1_test.c:51:test_has_digit:IGNORE: Not implemented yet
```

Τώρα θα πρέπει να συμπληρωθεί ορθή υλοποίηση για τη συνάρτηση <span class="p-style">has_digit()</span>. Η διαδικασία επαναλαμβάνεται μέχρι που ο κώδικας 14.5 στη <span class="p-style">ch14_p1.c</span> να είναι ο ακόλουθος:

```{.c title="Κώδικας 14.5: ch14_p1_sol.c - ο κώδικας του παραδείγματος με όλες τις συναρτήσεις συμπληρωμένες έτσι ώστε να «περνάνε» τους μοναδιαίους ελέγχους." linenums="1"}
--8<-- "src/ch14_p1_sol.c"
```

Τώρα, η μεταγλώττιση και εκτέλεση των ελέγχων θα επιστρέψει τα ακόλουθα:

```
$ gcc unity.c ch14_p1.c ch14_p1_test.c ‐o ch14_p1
$ ./ch14_p1
ch14_p1_test.c:49:test_has_size_ok:PASS
ch14_p1_test.c:50:test_has_digit:PASS
ch14_p1_test.c:51:test_has_lowercase_letter:PASS
ch14_p1_test.c:52:test_has_uppercase_letter:PASS
ch14_p1_test.c:53:test_is_valid_password:PASS
```



## 14.3 Ανάπτυξη οδηγούμενη από ελέγχους

Η οδηγούμενη από ελέγχους ανάπτυξη (TDD = Test Driven Development) είναι ένας τρόπος ανάπτυξης λογισμικού όπου γράφονται πρώτα οι έλεγχοι μονάδας, που αρχικά αποτυγχάνουν, και στη συνέχεια γράφονται οι μονάδες κώδικα που κάνουν τους ελέγχους να επιτύχουν. Έμφαση δίνεται στην αυτοματοποίηση της διαδικασίας με μεγάλο αριθμό μικρών ελέγχων, που μπορούν να εκτελεστούν μαζικά και συνήθως γρήγορα. Αυτό ίσως να δημιουργεί ενστάσεις καθώς μπορεί να έχει εδραιωθεί σε κάποιους προγραμματιστές η αντίληψη ότι «οι έλεγχοι γράφονται για κώδικα που δεν έχει την ορθή συμπεριφορά και εφόσον βέβαια έχει γραφεί ο κώδικας». Ωστόσο, στην πράξη, σφάλματα μπορούν να υπεισέρχονται στον κώδικα σε κάθε φάση ανάπτυξής του και η πολιτική της συγγραφής ελέγχων πρώτα και πριν την ανάπτυξη του κάθε νέου τμήματος κώδικα ή την τροποποίηση παλαιότερων τμημάτων κώδικα φαίνεται να οδηγεί σε κώδικα με λιγότερα σφάλματα συνολικά.  
Με δεδομένο ότι η ανάπτυξη λογισμικού είναι από τις συνθετότερες κατασκευές που μπορεί να δημιουργήσει ο άνθρωπος, είναι λογικό να αναμένουμε ότι σφάλματα θα υπάρχουν λόγω ακριβώς της ανθρώπινης φύσης. Η TDD αποτελεί έναν συστηματικό τρόπο με τον οποίο μεμονωμένοι προγραμματιστές ή και ομάδες προγραμματιστών μπορούν να ελέγξουν την πολυπλοκότητα και να ολοκληρώσουν σύνθετα έργα λογισμικού.  
Το παράδειγμα της παραγράφου 14.2.2 μπορεί να θεωρηθεί ως ένα απλοϊκό παράδειγμα TDD, καθώς αρχικά γράφηκαν οι έλεγχοι που θα έπρεπε να επαληθεύονται στο αρχείο <span class="p-style">ch14_p1_test.c</span>, ενώ ο κώδικας που υλοποιεί τη λειτουργικότητα, π.χ. η συνάρτηση <span class="p-style">has_size_ok()</span> που δηλώνεται στο <span class="p-style">ch14_p1.h</span> και ορίζεται στο <span class="p-style">ch14_p1.c</span> έχει κενό σώμα. Άρα, αρχικά ο έλεγχος για τη <span class="p-style">has_size_ok()</span> αποτυγχάνει, αλλά στη συνέχεια συμπληρώνοντας ο προγραμματιστής ορθά τον κώδικα της συνάρτησης ο έλεγχος θα επιτύχει. Η διαδικασία συνεχίζεται με αυτόν τον τρόπο επαυξητικά έτσι ώστε να υλοποιηθεί τελικά η πλήρης ζητούμενη λειτουργικότητα. Παράλληλα, με την ολοκλήρωση της διαδικασίας μένει διαθέσιμο και ένα σύνολο ελέγχων που αυτόματα μπορούν να ξανά-εκτελεστούν αν ο κώδικας χρειαστεί να τροποποιηθεί.

## 14.4 Ασκήσεις

***Άσκηση 1***  
Επεκτείνετε το παράδειγμα της παραγράφου 14.2.2 έτσι ώστε να προστεθούν οι δύο ακόλουθοι επιπλέον έλεγχοι για κάθε συνθηματικό:  

   1. Να μην είναι ένα από 20 εύκολα συνθηματικά που εντοπίζονται σε μια λίστα επισφαλών συνθη    ματικών όπως στη <a href="https://www.tomsguide.com/news/worst‐passwords‐2022" target="_blank">https://www.tomsguide.com/news/worst‐passwords‐2022</a>

   2. Να περιέχει τουλάχιστον 1 ειδικό χαρακτήρα από τους χαρακτήρες που ορίζονται ως ειδικοί στο     <a href="https://owasp.org/www‐community/password‐special‐characters" target="_blank">https://owasp.org/www-community/password-special-characters</a>  

Χρησιμοποιήστε τα αρχεία <span class="p-style">ch14_p1.h</span>, <span class="p-style">ch14_p1.c</span> και <span class="p-style">ch14_p1_test.c</span> πραγματοποιώντας αλλαγές μόνο στο <span class="p-style">ch14_p1.c</span>.


??? tip "Λύση άσκησης 1"
    === "ch14_e1_sol.c"
        ```{.c linenums="1"}
        --8<-- "src/ch14_e1_sol.c"
        ```  
    === "ch14_e1_test.c"
        ```{.c linenums="1"}
        --8<-- "src/ch14_e1_test.c"
        ```
    === "ch14_e1.c"
        ```{.c linenums="1"}
        --8<-- "src/ch14_e1.c"
        ```
    === "ch14_e1.h"
        ```{.c linenums="1"}
        --8<-- "src/ch14_e1.h"
        ```

***Άσκηση 2***  
Υλοποιήστε μια συνάρτηση <span class="p-style">long factorial(int n)</span> που υπολογίζει το παραγοντικό ενός μη αρνητικού ακεραίου <span class="p-style">n</span>. Το παραγοντικό του <span class="p-style">n</span> (συμβολίζεται με <span class="p-style">n!</span>) είναι το γινόμενο όλων των θετικών ακεραίων μικρότερων ή ίσων του <span class="p-style">n</span>, ενώ ισχύει επιπλέον ότι το 0! είναι 1. Γράψτε τους ακόλουθους μοναδιαίους ελέγχους:

* Μοναδιαίος έλεγχος για το παραγοντικό του 0 που πρέπει να είναι 1.
* Μοναδιαίος έλεγχος για το παραγοντικό του 1 που πρέπει να είναι 1.
* Μοναδιαίος έλεγχος για το παραγοντικό του 5 που πρέπει να είναι 120.
* Μοναδιαίος έλεγχος για το παραγοντικό του 10 που πρέπει να είναι 3628800.
* Μοναδιαίος έλεγχος για το παραγοντικό μιας αρνητικής τιμής. Η συνάρτηση θα πρέπει να επιστρέφει μια τιμή που έχει συμφωνηθεί ότι αντιστοιχεί σε αδυναμία υπολογισμού (π.χ. -1).

??? tip "Λύση άσκησης 2"
    ```{.c linenums="1"}
    --8<-- "src/ch14_e2.c"
    ```

***Άσκηση 3***  
Υλοποιήστε μια συνάρτηση <span class="p-style">int find_index(int* array, int size, int element)</span> που επιστρέφει τη θέση (<span class="p-style">index</span>) ενός στοιχείου <span class="p-style">element</span> εντός ενός πίνακα <span class="p-style">array</span> με μέγεθος <span class="p-style">size</span>. Αν το στοιχείο δεν υπάρχει, η συνάρτηση θα πρέπει να επιστρέφει -1. Γράψτε τους ακόλουθους μοναδιαίους ελέγχους: 

1. Μοναδιαίος έλεγχος για έλεγχο ότι η συνάρτηση επιστρέφει τη σωστή θέση όταν το στοιχείο που αναζητείται υπάρχει στον πίνακα.
2. Μοναδιαίος έλεγχος για έλεγχο ότι η συνάρτηση επιστρέφει την τιμή -1 όταν το στοιχείο που αναζητείται δεν υπάρχει στον πίνακα.
3. Μοναδιαίος έλεγχος για έλεγχο στην περίπτωση που ο πίνακας έχει μηδενικό μέγεθος.
4. Μοναδιαίος έλεγχος για έλεγχο στην περίπτωση που το στοιχείο που αναζητείται υπάρχει πολλές φορές στον πίνακα (θα πρέπει να επιστρέφει τη θέση της πρώτης εμφάνισης από αριστερά προς
τα δεξιά).  
Τοποθετήστε τη συνάρτηση int find_index(int* array, int size, int element)
σε ξεχωριστό αρχείο από το αρχείο κώδικα το οποίο θα περιέχει τους ελέγχους.

***Άσκηση 4***  
Υλοποιήστε λύσεις στα ακόλουθα προβλήματα από το C track του exercism:  

1. Απόσταση hamming <a href="https://exercism.org/tracks/c/exercises/hamming" target="_blank">https://exercism.org/tracks/c/exercises/hamming</a>
2. Πυθαγόρειες τριάδες <a href="https://exercism.org/tracks/c/exercises/pythagorean‐triplet" target="_blank">https://exercism.org/tracks/c/exercises/pythagorean‐triplet</a>
3. Υλοποίηση excel-like λειτουργικότητας <a href="https://exercism.org/tracks/c/exercises/react" target="_blank">https://exercism.org/tracks/c/exercises/react</a>

[^1]: James Grenning. “Test Driven Development for Embedded C”. Στο: <i>Test Driven Development for Embedded C </i>(2011), σσ. 1–356.