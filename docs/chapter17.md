# 17. Βιβλιοθήκες

<i>Σύνοψη</i> Η πρότυπη βιβλιοθήκη της C, το αρχείο επικεφαλίδας <span class="p-style">stdio.h</span>, οι συναρτήσεις <span class="p-style">snprintf()</span>, <span class="p-style">scanf()</span>, <span class="p-style">perror()</span>, το αρχείο επικεφαλίδας <span class="p-style">stdlib.h</span>, οι συναρτήσεις <span class="p-style">calloc()</span>, <span class="p-style">realloc()</span>, <span class="p-style">abort()</span>, <span class="p-style">atexit()</span>, <span class="p-style">srand()</span>, <span class="p-style">rand()</span>, <span class="p-style">system()</span>, <span class="p-style">bsearch()</span>, <span class="p-style">qsort()</span>, το αρχείο επικεφαλίδας <span class="p-style">string.h</span>, οι συναρτήσεις <span class="p-style">strncat()</span>, <span class="p-style">strncmp()</span>, <span class="p-style">strncpy()</span>, <span class="p-style">strdup()</span>, <span class="p-style">strndup()</span>, <span class="p-style">memset()</span>, <span class="p-style">memcmp()</span>, <span class="p-style">memcpy()</span>, <span class="p-style">memmove()</span>, το αρχείο επικεφαλίδας <span class="p-style">math.h</span>, οι συναρτήσεις <span class="p-style">ceil()</span>, <span class="p-style">floor()</span>, <span class="p-style">trunc()</span>, <span class="p-style">round()</span>, <span class="p-style">modf()</span>, <span class="p-style">fmod()</span>, <span class="p-style">sin()</span>, <span class="p-style">cos()</span>, <span class="p-style">tan()</span>, <span class="p-style">asin()</span>, <span class="p-style">acos()</span>, <span class="p-style">atan()</span>, το αρχείο επικεφαλίδας <span class="p-style">tgmath.h</span>, το αρχείο επικεφαλίδας <span class="p-style">time.h</span>, οι τύποι <span class="p-style">clock_t</span>, <span class="p-style">struct tm</span>, οι συναρτήσεις <span class="p-style">ctime()</span>, <span class="p-style">difftimef()</span>, <span class="p-style">gmtime()</span>, <span class="p-style">localtime()</span>, <span class="p-style">asctime()</span>, <span class="p-style">strftime()</span>, η σταθερά <span class="p-style">CLOCKS_PER_SEC</span>, εξωτερικές βιβλιοθήκες, το λογισμικό vcpkg, παράδειγμα κλήσης συναρτήσεων της βιβλιοθήκης GSL.  

<i>Προαπαιτούμενη γνώση</i> Τύποι δεδομένων, είσοδος/έξοδος, δομές επιλογής και επανάληψης, συναρτήσεις, πίνακες, δείκτες, αλφαριθμητικά, διαμερισμός κώδικα.

## 17.1 Η πρότυπη βιβλιοθήλκη της C

Η πρότυπη βιβλιοθήκη της C, η <span class="p-style">libc</span>, είναι μια συλλογή από συναρτήσεις, μακροεντολές και τύπους που αποτελεί τμήμα των προδιαγραφών της γλώσσας. Οι συναρτήσεις της πρότυπης βιβλιοθήκης υλοποιούν βασικές λειτουργίες που χρησιμοποιούνται συχνά και καθώς συμπεριλαμβάνονται στη γλώσσα δεν χρειάζεται να υλοποιηθούν εκ νέου από τον προγραμματιστή ούτε να αναζητηθούν εξωτερικές βιβλιοθήκες για αυτές. Η πρότυπη βιβλιοθήκη περιλαμβάνει διάφορα αρχεία επικεφαλίδων όπως τα <span class="p-style">stdio.h, stdlib.h, string.h, math.h, time.h</span> και άλλα, με το καθένα να παρέχει διαφορετικά σύνολα συναρτήσεων, τύπων και μακροεντολών.

### 17.1.1 stdio.h

Το αρχείο επικεφαλίδας stdio.h περιέχει συναρτήσεις όπως οι <span class="p-style">printf()</span>, <span class="p-style">scanf()</span>, <span class="p-style">fopen()</span>, <span class="p-style">fclose()</span>, <span class="p-style">fprintf()</span> και <span class="p-style">fscanf()</span> που είδαμε σε προηγούμενα κεφάλαια. Το <span class="p-style">stdio.h</span> περιέχει πολλές άλλες χρήσιμες συναρτήσεις. Στη συνέχεια θα παρουσιαστούν 3 από αυτές, η <span class="p-style">snprintf()</span>, η <span class="p-style">sscanf()</span> και η <span class="p-style">perror()</span>.   

<i><span class="p-style">snprintf()</span></i> Η συνάρτηση <span class="p-style">snprintf()</span> λειτουργεί παρόμοια με την <span class="p-style">printf()</span>, αλλά αποθηκεύει το μορφοποιημένο αλφαριθμητικό που παράγει σε ένα αλφαριθμητικό αντί να το εμφανίσει στην οθόνη. Τα τρία πρώτα υποχρεωτικά ορίσματα που δέχεται είναι: α) ένα αλφαριθμητικό εξόδου, β) το μέγιστο πλήθος χαρακτήρων που θα γραφούν στο αλφαριθμητικό εξόδου, συμπεριλαμβανομένου του συμβόλου '<span class="p-style">\0</span>', και γ) ένα αλφαριθμητικό μορφοποίησης, όπως αυτά που χρησιμοποιεί η <span class="p-style">printf()</span>. Επιστρέφει το πλήθος των χαρακτήρων που γράφονται στο αλφαριθμητικό εξόδου. Στον κώδικα 17.1 παρουσιάζεται ένα απλό παράδειγμα που εγγράφει σε ένα αλφαριθμητικό έναν ακέραιο και δύο πραγματικούς  αριθμούς. Στη συνέχεια, το αλφαριθμητικό εμφανίζεται στην οθόνη.

```{.c title="Κώδικας 17.1: ch17_p1.c - χρήση αλφαριθμητικού για την έξοδο τιμών." linenums="1"}
--8<-- "src/ch17_p1.c"
```

Ακολουθούν τα αποτελέσματα εκτέλεσης του κώδικα:

```
Characters written=20
a=10, b=2.73, c=3.14
```

Αξίζει να σημειωθεί ότι ισοδύναμη λειτουργικότητα παρέχει και η συνάρτηση <span class="p-style">sprintf()</span>, αλλά πλέον είναι deprecated (δηλαδή η χρήση της δεν συνίσταται και μπορεί να αποσυρθεί σε μελλοντικές εκδόσεις). Η προειδοποίηση που επιστρέφει ο μεταγλωττιστής gcc, αν χρησιμοποιηθεί ο διακόπτης <span class="p-style">‐fsanitize=address</span>, είναι να μη χρησιμοποιείται η <span class="p-style">sprintf()</span>, λόγω του ότι δεν παρέχει έλεγχο για πιθανή υπερχείλιση του αλφαριθμητικού στο οποίο κατευθύνεται η έξοδος.  

<i><span class="p-style">sscanf()</span></i> Η συνάρτηση <span class="p-style">sscanf()</span> λειτουργεί παρόμοια με την <span class="p-style">scanf()</span>, αλλά αντί να διαβάζει την είσοδο από το πληκτρολόγιο, διαβάζει από ένα αλφαριθμητικό. Δέχεται δύο κύρια ορίσματα, ένα αλφαριθμητικό εισόδου και ένα αλφαριθμητικό μορφοποίησης που ορίζει την αναμενόμενη μορφή των δεδομένων εισόδου, όπως στην <span class="p-style">scanf()</span>. Η <span class="p-style">sscanf()</span> διαβάζει δεδομένα από το αλφαριθμητικό εισόδου και αναθέτει τιμές με βάση το αλφαριθμητικό μορφοποίησης σε αντίστοιχες μεταβλητές που περνούν ως επιπλέον ορίσματα μετά το αλφαριθμητικό μορφοποίησης. Η συνάρτηση επιστρέφει το πλήθος των εισόδων που αντιστοιχίστηκαν επιτυχώς και ανατέθηκαν ή <span class="p-style">EOF</span> αν συμβεί κάποιο σφάλμα (π.χ. κενό αλφαριθμητικό εισόδου). Ο κώδικας 17.2 είναι ένα παράδειγμα χρήσης της <span class="p-style">sscanf()</span>, όπου η είσοδος τιμών για 3 μεταβλητές δίνεται από ένα αλφαριθμητικό.

```{.c title="Κώδικας 17.2: ch17_p2.c - ανάγνωση εισόδου από ένα αλφαριθμητικό." linenums="1"}
--8<-- "src/ch17_p2.c"
```

Η εκτέλεση του προγράμματος θα δώσει την ακόλουθη έξοδο:

```
3 values read.
First Name: Jane, Last Name: Doe, Age: 25
```

<i><span class="p-style">perror()</span></i> Ορισμένες συναρτήσεις της πρότυπης βιβλιοθήκης, αλλά και συναρτήσεις άλλων βιβλιοθηκών, έχουν γραφεί έτσι ώστε όταν προκαλείται ένα σφάλμα η καθολική μεταβλητή <span class="p-style">errno</span> που ορίζεται στο <span class="p-style">errno.h</span> να λαμβάνει μια αναγνωριστική τιμή σφάλματος. Η διαδικασία που ακολουθείται για τον χειρισμό λαθών που θέτουν τιμή στην <span class="p-style">errno</span> είναι η ακόλουθη:

1. Κλήση συνάρτησης που μπορεί να προκαλέσει κάποια κατάσταση σφάλματος.
2. Αν το σφάλμα προκληθεί, τότε η συνάρτηση επιστρέφει μια τιμή που υποδηλώνει ότι συνέβη πρόβλημα (π.χ. <span class="p-style">NULL</span> ή -1 ή κάποια άλλη τιμή).
3. Ο κώδικας που κάλεσε τη συνάρτηση ελέγχει την τιμή του <span class="p-style">errno</span> για να καθορίσει τον τύπο του σφάλματος.
4. Χειρισμός λάθους (π.χ. εμφάνιση μηνύματος λάθους, καταγραφή λάθους, τερματισμός προγράμματος).

Η συνάρτηση <span class="p-style">perror()</span> χρησιμοποιείται κυρίως για να εμφανίσει μηνύματα αποσφαλμάτωσης. Η κλήση της εμφανίζει ένα μήνυμα που ορίζει ο προγραμματιστής που ακολουθείται από τον χαρακτήρα <span class="p-style">:</span> και την περιγραφή του πλέον πρόσφατου σφάλματος που συνέβη και έθεσε την τιμή του <span class="p-style">errno</span>.  
Παραδείγματα συναρτήσεων που μπορεί να προκαλέσουν σφάλματα κατά την κλήση τους είναι η <span class="p-style">fopen()</span> της <span class="p-style">stdio.h</span>, η <span class="p-style">malloc()</span> της <span class="p-style">stdlib.h</span>, η <span class="p-style">read()</span> της <span class="p-style">unistd.h</span> και άλλες. Στον κώδικα 17.3 παρουσιάζεται ένα παράδειγμα που η <span class="p-style">fopen()</span> θέτει την τιμή του <span class="p-style">errno</span> επιχειρώντας να ανοίξει ένα αρχείο που δεν εντοπίζεται.

```{.c title="Κώδικας 17.3: ch17_p3.c - αποτυχημένο άνοιγμα αρχείου και χειρισμός του λάθους που προκύπτει." linenums="1"}
--8<-- "src/ch17_p3.c"
```

Η έξοδος του προγράμματος, δεδομένου ότι το αρχείο <span class="p-style">non_existent_file.txt</span> δεν υπάρχει στο σύστημα είναι:

```
errno=2
Error opening file: No such file or directory
```

### 17.1.2 stdlib.h

Το <span class="p-style">stdlib.h</span> περιέχει συναρτήσεις για δέσμευση και αποδέσμευση μνήμης όπως η <span class="p-style">malloc()</span> και η <span class="p-style">free()</span>, συναρτήσεις για έλεγχο διεργασιών όπως η <span class="p-style">exit()</span>, συναρτήσεις μετατροπής αλφαριθμητικού σε ακέραιο όπως η <span class="p-style">atoi()</span>, συναρτήσεις παραγωγής τυχαίων τιμών όπως η <span class="p-style">rand()</span> και η <span class="p-style">srand()</span>, καθώς και άλλες συναρτήσεις. Στη συνέχεια θα εξεταστούν μερικές βασικές δυνατότητες που προσφέρει η <span class="p-style">stdlib.h</span>.  
  
Δυναμική δέσμευση μνήμης Εκτός από τη <span class="p-style">malloc()</span> υπάρχουν και άλλες συναρτήσεις δυναμικής δέσμευσης μνήμης όπως η <span class="p-style">calloc()</span> και η <span class="p-style">realloc()</span>, όπως είδαμε στην παράγραφο 9.1.5. H <span class="p-style">calloc()</span> δέχεται δύο ορίσματα, το πλήθος των στοιχείων που θα δεσμεύσει σε συνεχόμενες θέσεις μνήμης και το μέγεθος σε bytes κάθε στοιχείου. Επιστρέφει έναν δείκτη προς το πρώτο byte του μπλοκ μνήμης που δεσμεύει, αρχικοποιώντας όλα τα bytes σε μηδέν. Αν αποτύχει η δέσμευση μνήμης, η <span class="p-style">calloc()</span> επιστρέφει την τιμή <span class="p-style">NULL</span>. Η <span class="p-style">realloc()</span> χρησιμοποιείται για να αλλάξει μέγεθος σε μνήμη που έχει δεσμευθεί σε προηγούμενη δέσμευση μνήμης. Δέχεται ως ορίσματα έναν δείκτη προς δεσμευμένη μνήμη και το μέγεθος της μνήμης που θα δεσμευθεί. Η <span class="p-style">realloc()</span>, στην περίπτωση που αυξάνει το μέγεθος της μνήμης που δεσμεύει σε σχέση με πριν, διατηρεί τα δεδομένα της προηγούμενης δεσμευμένης μνήμης. Ακολουθεί, στον κώδικα 17.4, ένα παράδειγμα που αρχικά δεσμεύεται δυναμικά χώρος μνήμης για έναν πίνακα 5 ακεραίων, με την <span class="p-style">calloc()</span> αρχικοποιώντας όλες τις τιμές του πίνακα με μηδέν. Στη συνέχεια, με τη <span class="p-style">realloc()</span> ο δεσμευμένος χώρος επεκτείνεται έτσι ώστε να διατηρεί πλέον 10 θέσεις ακεραίων

```{.c title="Κώδικας 17.4: ch17_p4.c - αρχική δυναμική δέσμευση πίνακα και μετέπειτα επέκτασή του με τη realloc()." linenums="1"}
--8<-- "src/ch17_p4.c"
```

Η εκτέλεση του προγράμματος δίνει τα ακόλουθα αποτελέσματα:

```
Initial memory allocation successful!
0 0 0 0 0
Memory reallocation successful!
0 0 0 0 0 0 0 0 0 0
```

Αξίζει να σημειωθεί ότι οι 5 πρώτες τιμές του πίνακα αναμένεται σε κάθε εκτέλεση να έχουν μηδενική τιμή (πριν και μετά την αλλαγή μεγέθους). Οι υπόλοιπες θέσεις του πίνακα, αν και συμβαίνει στο συγκεκριμένο παράδειγμα εκτέλεσης, δεν υπάρχει εγγύηση ότι θα είναι μηδενικές.

<i><span class="p-style">Χειρισμός τερματισμού προγραμμάτων</span></i> Μια άλλη ομάδα συναρτήσεων είναι οι <span class="p-style">exit()</span>, <span class="p-style">abort()</span> και <span class="p-style">atexit()</span> που πραγματοποιούν τερματισμό του προγράμματος και την εκτέλεση ενεργειών πριν τον τερματισμό του. Η συνάρτηση <span class="p-style">exit()</span> προκαλεί κανονικό τερματισμό του προγράμματος και επιστροφή του ελέγχου στο λειτουργικό σύστημα. Δέχεται ως όρισμα μια ακέραια τιμή, την κατάσταση εξόδου (exit status), που υποδηλώνει την κατάσταση με την οποία τερμάτισε την εκτέλεσή του το πρόγραμμα. Η τιμή αυτή μπορεί να ληφθεί με εντολές που θα αναφερθούν στη συνέχεια σε συστήματα Linux, MacOS ή Windows και μπορούν να χρησιμοποιούνται, για παράδειγμα, σε shell scripts για να καθοδηγήσουν την εκτέλεση μιας ομάδας ενεργειών. Στο ακόλουθο παράδειγμα (κώδικας 17.5) καλείται είτε η <span class="p-style">exit()</span> είτε η <span class="p-style">abort()</span>.


```{.c title="Κώδικας 17.5: ch17_p5.c - κλήση των συναρτήσεων exit() και abort(), ανάλογα με την είσοδο του χρήστη." linenums="1"}
--8<-- "src/ch17_p5.c"
```

Ακολουθούν αποτελέσματα 3 εκτελέσεων του κώδικα. Σε κάθε περίπτωση, η κατάσταση εξόδου του προγράμματος (αν έχει τεθεί) λαμβάνεται με την εντολή <span class="p-style">echo $?</span> σε Linux ή σε MacOS. Αν η έξοδος έχει γίνει με την <span class="p-style">exit()</span> ή την <span class="p-style">return()</span> τότε η κατάσταση εξόδου είναι η τιμή του ορίσματος που έχει περάσει στη συνάρτηση. Αν η έξοδος γίνεται με το <span class="p-style">abort()</span>, τότε δεν λαμβάνεται πίσω κάποια τιμή με νόημα ως κατάσταση εξόδου του προγράμματος (για παράδειγμα, η συγκεκριμένη εκτέλεση επιστρέφει την τιμή 134).

```
$ ./ch17_p5
How do you want to stop the program (1=exit, 2=abort, 3=return)? 1
Let's set the exit status to 99.
$ echo $?
99
$ ./ch17_p5
How do you want to stop the program (1=exit, 2=abort, 3=return)? 2
Abort.
zsh: abort  ch17_p5
$ echo $?
134
$ ./ch17_p5
How do you want to stop the program (1=exit, 2=abort, 3=return)? 3
$ echo $?
0
```

Αν το πρόγραμμα μεταγλωττιστεί και εκτελεστεί σε Windows, τότε η κατάσταση εξόδου λαμβάνεται με την εντολή:

```
> echo %ERRORLEVEL%
```

Επιπλέον, η συνάρτηση <span class="p-style">atexit()</span> μπορεί να χρησιμοποιηθεί έτσι ώστε να εκτελεστεί κάποιος κώδικας όταν το πρόγραμμα τερματίσει κανονικά την εκτέλεσή του. Η συνάρτηση <span class="p-style">atexit()</span> δέχεται ως όρισμα μια συνάρτηση που θα εκτελεστεί όταν το πρόγραμμα τερματιστεί επιτυχώς και συνήθως χρησιμοποιείται για αποδέσμευση πόρων και εμφάνιση μηνυμάτων. Στον κώδικα 17.6 παρουσιάζεται ένα παράδειγμα χρήσης της <span class="p-style">atexit()</span>.

```{.c title="Κώδικας 17.6: ch17_p6.c - κλήση συνάρτησης ακριβώς πριν τον τερματισμό εκτέλεσης του προγράμματος." linenums="1"}
--8<-- "src/ch17_p6.c"
```

Ακολουθεί ένα παράδειγμα εκτέλεσης.

```
Program Started
Ready to exit (y/n)? y
Program terminated blissfully!
```

<i><span class="p-style">Δημιουργία τυχαίων αριθμών</span></i> Οι δύο συναρτήσεις του <span class="p-style">stdlib.h</span> που επιτρέπουν τη δημιουργία ψευδοτυχαίων τιμών είναι η <span class="p-style">srand()</span> και η <span class="p-style">rand()</span>. H <span class="p-style">srand()</span>, δέχεται ως όρισμα το λεγόμενο seed (σπόρος). Αν παραλειφθεί, χρησιμοποιείται ως seed η τιμή 1. Αν εκτελεστεί μια διαδικασία παραγωγής τυχαίων αριθμών και χρησιμοποιηθεί το ίδιο seed, τότε οι ψευδοτυχαίες τιμές που θα εμφανιστούν θα είναι οι ίδιες με την προηγούμενη εκτέλεση. Για να λαμβάνονται διαφορετικές τιμές σε κάθε εκτέλεση, συνήθως χρησιμοποιείται η τιμή που επιστρέφει η κλήση <span class="p-style">time(NULL)</span> που όπως θα δούμε και στη συνέχεια του ίδιου κεφαλαίου, επιστρέφει το πλήθος δευτερολέπτων της χρονικής στιγμής που πραγματοποιείται η εκτέλεση από την ημερομηνία και ώρα 1/1/1970 00:00:00. Η <span class="p-style">rand()</span> επιστρέφει μια τυχαία ακέραια τιμή από 0 μέχρι <span class="p-style">RAND_MAX</span>. H <span class="p-style">RAND_MAX</span> ορίζεται στη <span class="p-style">stdlib.h</span> και το πρότυπο της γλώσσας αναφέρει ότι θα πρέπει να έχει ελάχιστη τιμή <span class="p-style">2^15^ − 1 = 32767</span>. Ωστόσο, σε πολλές σύγχρονες υλοποιήσεις η τιμή του RAND_MAX είναι η μέγιστη τιμή που μπορεί να λάβει ένας προσημασμένος ακέραιος 32-bit, που είναι <span class="p-style">2^31^ − 1 = 2147483647</span>. Στον κώδικα 17.7 παρουσιάζεται ένα παράδειγμα δημιουργίας 10 ακεραίων τιμών, επί δύο φορές, με κάθε ακέραια τιμή να βρίσκεται στο διάστημα από 1 έως και 10.

```{.c title="Κώδικας 17.7: ch17_p7.c - δημιουργία 10 τυχαίων τιμών με seed την τιμή 42 και δημιουργία άλλων 10 τυχαίων τιμών με seed μια τιμή που αλλάζει σε κάθε εκτέλεση." linenums="1"}
--8<-- "src/ch17_p7.c"
```

Ακολουθούν τα αποτελέσματα που παράγονται από δύο εκτελέσεις του κώδικα. Η πρώτη εκτέλεση εμφανίζει:

```
  5  4  10  4  7   2  2  1  1  6
 10  5   6  6  2  10  1  9  9  8
```

Η δεύτερη εκτέλεση εμφανίζει:

```
 5  4  10  4  7   2  2  1  1  6
 7  8   9  5  8  10  2  6  1  8
```

Η πρώτη γραμμή της εξόδου είναι ίδια και στις δύο περιπτώσεις (διότι έχει χρησιμοποιηθεί το ίδιο seed), ενώ η δεύτερη διαφέρει.  
Ένα μειονέκτημα της ανάθεσης τιμής στο seed με το <span class="p-style">time(NULL)</span> είναι ότι η τιμή που επιστρέφει το <span class="p-style">time(NULL)</span> αλλάζει σχετικά αργά (κάθε δευτερόλεπτο), οπότε αν το πρόγραμμα εκτελείται ξανά σε διάστημα μικρότερο του ενός δευτερολέπτου, οι τυχαίες τιμές θα είναι οι ίδιες. Για να αποφευχθεί αυτή η συμπεριφορά μπορεί να χρησιμοποιηθεί η συνάρτηση <span class="p-style">gettimeofday()</span> από το <span class="p-style">sys/time.h</span> που επιστρέφει το χρονικό διάστημα από 1/1/1970 00:00:00 μέχρι την τρέχουσα χρονική στιγμή με ακρίβεια μικροδευτερολέπτων. Ο κώδικας 17.8 παρουσιάζει την παραγωγή 5 ομάδων πραγματικών τυχαίων αριθμών στο διάστημα από 0 μέχρι 1, χρησιμοποιώντας τη συνάρτηση <span class="p-style">gettimeofday()</span>.


```{.c title="Κώδικας 17.8: ch17_p8.c - δημιουργία τυχαίων τιμών με seed τιμή που επιστρέφει η συνάρτηση gettimeofday()." linenums="1"}
--8<-- "src/ch17_p8.c"
```

Ακολουθεί ένα παράδειγμα εκτέλεσης:

```
SEED = 774255
0.0596 0.7902 0.1987 0.1579 0.6974 0.2448 0.5293 0.4014 0.6387 0.6481
0.4010 0.7232 0.0741 0.6294 0.9382 0.0232 0.7664 0.3592 0.4847 0.9366
0.6032 0.2064 0.1106 0.1082 0.9458 0.2407 0.2765 0.0262 0.5820 0.3237
0.4546 0.6432 0.5426 0.6371 0.0795 0.9908 0.5744 0.6008 0.6509 0.2925
0.0924 0.4719 0.4286 0.5220 0.5141 0.4083 0.3387 0.9178 0.0553 0.7129
```

Αλληλεπίδραση με το λειτουργικό σύστημα Η συνάρτηση <span class="p-style">system()</span> επιτρέπει την εκτέλεση προγραμμάτων που θα μπορούσαν να εκτελεστούν από τη γραμμή εντολών. Ο κώδικας 17.9 είναι ένα παράδειγμα που ανάλογα με το είδος του λειτουργικού συστήματος (Linux, Windows, MacOS), εκτελείται μια εντολή που εμφανίζει πληροφορίες για το υλικό του συστήματος.

```{.c title="Κώδικας 17.9: ch17_p9.c - επιστροφή πληροφοριών συστήματος." linenums="1"}
--8<-- "src/ch17_p9.c"
```

Η ακόλουθη έξοδος είναι τα αποτέλεσμα της εκτέλεσης σε ένα σύστημα MacOS:

```
System Information:
Hardware:
    Hardware Overview:
        Model Name: Mac mini
        Model Identifier: Mac14 ,12
        Model Number: MNH73LL/A
        Chip: Apple M2 Pro
        Total Number of Cores: 10 (6 performance and 4 efficiency)
        Memory: 16 GB
        System Firmware Version: 10151.1.1
        OS Loader Version: 10151.1.1
        Serial Number (system): XXXXXXXXX
        Hardware UUID: XXXX‐XXXX‐XXXX‐XXXX‐XXXXXXXXXXX
        Provisioning UDID: XXXXXXXX ‐XXXXXXXXXXXX
        Activation Lock Status: Enabled
```

<i><span class="p-style">Συνάρτηση γρήγορης ταξινόμησης και συνάρτηση δυαδικής αναζήτησης</span></i> Οι συναρτήσεις <span class="p-style">qsort()</span> και <span class="p-style">bsearch()</span> πραγματοποιούν ταξινόμηση και αναζήτηση αντίστοιχα. Η <span class="p-style">qsort()</span> υλοποιεί τον αλγόριθμο γρήγορης ταξινόμησης και μπορεί να χρησιμοποιηθεί για να ταξινομήσει αριθμούς, αλφαριθμητικά, και σύνθετες δομές. Έχει τέσσερις παραμέτρους: έναν δείκτη προς τον πίνακα που θα ταξινομηθεί, το πλήθος των στοιχείων του πίνακα, το μέγεθος κάθε στοιχείου σε bytes και μια συνάρτηση σύγκρισης. Η συνάρτηση σύγκρισης καλείται από την <span class="p-style">qsort()</span> κάθε φορά που πρέπει να συγκριθούν δύο στοιχεία. Αν επιστρέψει αρνητική τιμή σημαίνει ότι το πρώτο στοιχείο είναι μικρότερο του δεύτερου, αν επιστρέψει μηδέν σημαίνει ότι είναι ίσα και αν επιστρέψει θετική τιμή σημαίνει ότι το πρώτο στοιχείο είναι μεγαλύτερο του δεύτερου. Συνεπώς, ο προγραμματιστής πρέπει να γράψει την κατάλληλη συνάρτηση σύγκρισης και να την περάσει ως τέταρτο όρισμα στην <span class="p-style">qsort()</span> κατά την κλήση της. Η συνάρτηση <span class="p-style">bsearch()</span> υλοποιεί τον αλγόριθμο δυαδικής αναζήτησης που εντοπίζει τη θέση μιας τιμής σε έναν πίνακα. Πρόκειται για έναν ταχύτατο αλγόριθμο, αλλά απαιτεί ο πίνακας στον οποίο γίνεται η αναζήτηση να είναι διατεταγμένος σε αύξουσα σειρά. Η <span class="p-style">bsearch()</span> έχει πέντε παραμέτρους: την τιμή αναζήτησης, έναν δείκτη προς τον πίνακα στον οποίο θα γίνει αναζήτηση, το πλήθος των στοιχείων του πίνακα, το μέγεθος κάθε στοιχείου σε bytes και μια συνάρτηση σύγκρισης. Στο παράδειγμα του κώδικα 17.10, χρησιμοποιούνται και οι δύο συναρτήσεις. Αρχικά, ένας πίνακας ταξινομείται σε αύξουσα σειρά και στη συνέχεια ζητείται για μια συγκεκριμένη τιμή εάν υπάρχει στον πίνακα. Η συνάρτηση σύγκρισης <span class="p-style">cmp()</span> που περνά ως τελευταίο όρισμα και στις δύο συναρτήσεις, δέχεται με τη σειρά της ως ορίσματα δείκτες προς ακεραίους, οπότε στο σώμα της πραγματοποιείται αποαναφορά και στους δύο δείκτες για να επιστραφεί το σωστό αποτέλεσμα.

```{.c title="Κώδικας 17.10: ch17_p10.c - ταξινόμηση πίνακα και μετά δυαδική αναζήτηση για εντοπισμό της θέσης μιας τιμής στον πίνακα." linenums="1"}
--8<-- "src/ch17_p10.c"
```

Το αποτέλεσμα της εκτέλεσης του προγράμματος θα είναι:

```
Ταξινομημένος πίνακας: 1 3 5 7 10 15 20 25 30 40
Το στοιχείο 25 βρέθηκε στη θέση 7.
```

### 17.1.3 string.h

Στο κεφάλαιο 8, στην παράγραφο 8.6, παρουσιάστηκαν 4 βασικές συναρτήσεις που ορίζονται στο <span class="p-style">string.h</span>, η <span class="p-style">strlen()</span> για υπολογισμό του μήκους ενός αλφαριθμητικού, η <span class="p-style">strcat()</span> για συνένωση αλφαριθμητικών, η <span class="p-style">strcmp()</span> για σύγκριση αλφαριθμητικών και η <span class="p-style">strtok()</span> για διαχωρισμό ενός αλφαριθμητικού σε τμήματα. Για τις <span class="p-style">strcat()</span>, <span class="p-style">strcmp()</span> καθώς και για τη <span class="p-style">strcpy()</span> που πραγματοποιεί αντιγραφή ενός αλφαριθμητικού σε ένα άλλο, υπάρχουν άλλες εκδόσεις τους που το όνομά τους σχηματίζεται παρεμβάλλοντας το γράμμα <span class="p-style">n</span> μετά τα τρία πρώτα γράμματα (<span class="p-style">str</span>) των συναρτήσεων. Έτσι, προκύπτουν οι συναρτήσεις <span class="p-style">strncat()</span>, <span class="p-style">strncmp()</span>, <span class="p-style">strncpy()</span> που δέχονται ένα επιπλέον όρισμα <span class="p-style">n</span> και εφαρμόζουν την αντίστοιχη ενέργεια στους <span class="p-style">n</span> πρώτους χαρακτήρες μόνο. Οι συναρτήσεις αυτές θεωρούνται ασφαλείς, καθώς δεν επιτρέπουν την υπερχείλιση των αλφαριθμητικών που δέχονται ως όρισμα εξόδου. Στον κώδικα 17.11, παρουσιάζεται ένα παράδειγμα χρήσης των συναρτήσεων που αναφέρθηκαν.

```{.c title="Κώδικας 17.11: ch17_p11.c - χρήση ασφαλών συναρτήσεων για χειρισμό αλφαριθμητικών." linenums="1"}
--8<-- "src/ch17_p11.c"
```

Η κλήση της συνάρτησης <span class="p-style">strncpy()</span> στη γραμμή 10 αντιγράφει τους 22 πρώτους χαρακτήρες από το αλφαριθμητικό <span class="p-style">source</span> στο αλφαριθμητικό <span class="p-style">result</span>, προσθέτοντας και τον χαρακτήρα <span class="p-style">'\0'</span> στη θέση 23. Στη συνέχεια, δύο διαδοχικές κλήσεις της <span class="p-style">strncat()</span> προσθέτουν στο τέλος του αλφαριθμητικού <span class="p-style">result</span> τμήματα του αλφαριθμητικού <span class="p-style">source</span>. Τέλος, για κάθε συνδυασμό ανά δύο των 3 αλφαριθμητικών της γραμμής 20, πραγματοποιείται σύγκριση εξετάζοντας μόνο τους 2 πρώτους χαρακτήρες κάθε αλφαριθμητικού και εμφανίζεται η λεξικογραφική σειρά μεταξύ τους. Η έξοδος του προγράμματος είναι:

```
Original=Controlling complexity is the essence of computer programming.
Partially copied=Controlling complexity
Concatenated=Controlling complexity is programming.
Comparisons using the first 2 letters of each string:
ABCD and ABCD are equal.
ABCD and ABEF are equal.
ABCD is less than BCDE.
ABEF and ABCD are equal.
ABEF and ABEF are equal.
ABEF is less than BCDE.
BCDE is greater than ABCD.
BCDE is greater than ABEF.
BCDE and BCDE are equal.
```

<i><span class="p-style">Η συνάρτηση strdup()</span></i> Οι <span class="p-style">strdup()</span> και <span class="p-style">strndup()</span> είναι δύο συναρτήσεις που πρόσφατα προστέθηκαν στο <span class="p-style">string.h</span> (με το πρότυπο C23), αν και υποστηρίζονται από τους διαδεδομένους μεταγλωττιστές της C εδώ και πολλά χρόνια. Η <span class="p-style">strdup()</span> επιστρέφει έναν δείκτη σε ένα αλφαριθμητικό που τερματίζεται με <span class="p-style">'\0'</span>, που είναι αντίγραφο του αλφαριθμητικού που δέχεται ως όρισμα. Καθώς ο δείκτης που επιστρέφεται δείχνει προς θέσεις μνήμης που έχουν δεσμευθεί στον σωρό, θα πρέπει να ακολουθεί εντολή απελευθέρωσης της μνήμης, όταν πλέον δεν χρησιμοποιείται. Στον κώδικα 17.12 παρουσιάζεται ένα παράδειγμα χρήσης των συναρτήσεων <span class="p-style">strdup()</span> και <span class="p-style">strndup()</span>. Στη γραμμή 8 ορίζεται μια τοπική μεταβλητή αλφαριθμητικού που παύει να υπάρχει στη γραμμή 12. H <span class="p-style">strdup()</span> δημιουργεί ένα αντίγραφο των περιεχομένων της <span class="p-style">t</span> στον σωρό και επιστρέφει έναν δείκτη που αποθηκεύεται στο <span class="p-style">s1</span>. Παρόμοια, η <span class="p-style">stdndup()</span> δημιουργεί αντίγραφο μόνο των 25 πρώτων χαρακτήρων του <span class="p-style">t</span> στον σωρό. Η συνάρτηση <span class="p-style">strcpy()</span> αντιγράφει το <span class="p-style">t</span> στον πίνακα <span class="p-style">s3</span> που διατηρείται στη στοίβα. Οι γραμμές 16, 17, με δύο κλήσεις της <span class="p-style">free()</span>, απελευθερώνουν τη μνήμη που έχει δεσμευθεί έμμεσα από τις <span class="p-style">strdup()</span> και <span class="p-style">strndup()</span>.

```{.c title="Κώδικας 17.12: ch17_p12.c - κλήση της συνάρτησης strdup() και της strndup()." linenums="1"}
--8<-- "src/ch17_p12.c"
```

Ακολουθεί η έξοδος της εκτέλεσης του κώδικα. Οι διευθύνσεις που εμφανίζονται, και αφορούν τα αλφαριθμητικά <span class="p-style">s1</span>, <span class="p-style">s2</span> και <span class="p-style">s3</span>, υποδηλώνουν ότι τα <span class="p-style">s1</span> και <span class="p-style">s2</span> βρίσκονται σε διαφορετική περιοχή μνήμης από το <span class="p-style">s3</span> (σωρό και στοίβα αντίστοιχα).

```
string at 0x130606b10: First, solve the problem. Then, write the code.
string at 0x130606a70: First, solve the problem.
string at 0x16ce9ae18: First, solve the problem. Then, write the code.
```

<i><span class="p-style">Συναρτήσεις χειρισμού μπλοκ μνήμης</span></i>  Μια χρήσιμη ομάδα συναρτήσεων του <span class="p-style">string.h</span>, που χειρίζονται μπλοκ μνήμης αντί για αλφαριθμητικά, αποτελείται από συναρτήσεις όπως οι <span class="p-style">memset()</span>, <span class="p-style">memcmp()</span> και <span class="p-style">memcpy()</span>. Στον κώδικα 17.13 δίνεται ένα παράδειγμα χρήσης αυτών των συναρτήσεων.

```{.c title="Κώδικας 17.13: ch17_p13.c - εργασία με αλφαριθμητικά με τις συναρτήσεις memset(), memcpy() και memcmp()." linenums="1"}
--8<-- "src/ch17_p13.c"
```

Ακολουθεί το αποτέλεσμα της εκτέλεσης του κώδικα:

```
After memset, the destination is:
*******************************************************************************
After memcpy, the destination is:
**************Never trust a computer you can't throw out a window**************
BAD and BAD are equal.
BAD is greater than AD.
BAD is less than D.
```

Η διαφορά των συναρτήσεων <span class="p-style">memcpy()</span> και <span class="p-style">strcpy()</span> είναι ότι ενώ η <span class="p-style">memcpy()</span> αντιγράφει ένα πλήθος bytes από ένα μπλοκ μνήμης σε ένα άλλο, η <span class="p-style">strcpy()</span> αντιγράφει τα περιεχόμενα ενός αλφαριθμητικού σε ένα άλλο αλφαριθμητικό. Έτσι, ενώ η <span class="p-style">memcpy()</span> εφαρμόζεται σε μπλοκ μνήμης, η <span class="p-style">strcpy()</span> εφαρμόζεται σε αλφαριθμητικά.  
Το <span class="p-style">string.h</span> ορίζει και τη συνάρτηση <span class="p-style">memmove(</span> που έχει παρόμοια λειτουργικότητα με τη <span class="p-style">memcpy()</span> καθώς και οι δύο αντιγράφουν ένα μπλοκ μνήμης σε ένα άλλο. Ωστόσο, αν τα δύο αυτά μπλοκ μνήμης επικαλύπτονται τότε μόνο η <span class="p-style">memmove(</span> δίνει εγγυημένα σωστά αποτελέσματα, ενώ η <span class="p-style">memcpy()</span> παρουσιάζει ακαθόριστη συμπεριφορά (undefined behavior).

### 17.1.4 math.h

Το <span class="p-style">math.h</span> περιέχει τριγωνομετρικές συναρτήσεις όπως οι <span class="p-style">sin()</span>, <span class="p-style">cos()</span>, <span class="p-style">tan()</span>, λογαριθμικές συναρτήσεις όπως οι <span class="p-style">log()</span>, <span class="p-style">log10()</span>, και άλλες μαθηματικές συναρτήσεις όπως η <span class="p-style">sqrt()</span>, η <span class="p-style">cbrt()</span> και η <span class="p-style">pow()</span> για υπολογισμό τετραγωνικής ρίζας, κυβικής ρίζας και ύψωσης σε δύναμη αντίστοιχα. Στη συνέχεια θα παρουσιαστούν ορισμένες συναρτήσεις του <span class="p-style">math.h</span> ξεκινώντας με τις συναρτήσεις <span class="p-style">ceil()</span>, <span class="p-style">floor()</span>, <span class="p-style">round()</span> και <span class="p-style">trunc()</span>. Η συνάρτηση <span class="p-style">ceil()</span> δέχεται ως παράμετρο μια πραγματική τιμή <span class="p-style">x</span> και επιστρέφει τον μικρότερο ακέραιο αριθμό που είναι μεγαλύτερος ή ίσος του <span class="p-style">x</span>. Αντίστοιχα, η <span class="p-style">floor()</span> επιστρέφει τον μεγαλύτερο ακέραιο που είναι μικρότερος ή ίσος του <span class="p-style">x</span>. Η <span class="p-style">round()</span> κάνει στρογγυλοποίηση, ενώ η <span class="p-style">trunc()</span> αφαιρεί (truncate) το κλασματικό μέρος. Ο πίνακας 17.1 συνοψίζει τη συμπεριφορά των συναρτήσεων.

<div style="text-align: center;"><b>Πίνακας 17.1:</b><i> Διαφορές μεταξύ των συναρτήσεων ceil(), floor(), trunc() και round().</i></div>

| Συνάρτηση | Λειτουργία                                     | Αποτέλεσμα για θετικό x                                            | Αποτέλεσμα για αρνητικό x                                           | Παραδείγματα                      |
|-----------|------------------------------------------------|--------------------------------------------------------------------|---------------------------------------------------------------------|----------------------------------|
| <span class="p-style">ceil(x)</span> | Στρογγυλοποίηση προς τα πάνω, στον πλησιέστερο ακέραιο | Μικρότερος ακέραιος που είναι μεγαλύτερος ή ίσος του x             | Διατήρηση του ακέραιου μέρους                                       | <span class="p-style">ceil(2.3)=3.0</span>, <span class="p-style">ceil(-2.3)=-2.0</span> |
| <span class="p-style">floor(x)</span>| Στρογγυλοποίηση προς τα κάτω, στον πλησιέστερο ακέραιο | Μεγαλύτερος ακέραιος που είναι μικρότερος ή ίσος του x             | Μεγαλύτερος ακέραιος που είναι μικρότερος ή ίσος του x              | <span class="p-style">floor(2.3)=2.0</span>, <span class="p-style">floor(-2.3)=-3.0</span> |
| <span class="p-style">trunc(x)</span>| Αφαίρεση του δεκαδικού μέρους                   | Αφαίρεση του δεκαδικού μέρους του x                                | Αφαίρεση του δεκαδικού μέρους του x                                 | <span class="p-style">trunc(2.3)=2.0</span>, <span class="p-style">trunc(-2.3)=-2.0</span> |
| <span class="p-style">round(x)</span>| Στρογγυλοποίηση προς τον πλησιέστερο ακέραιο    | Αν το κλασματικό μέρος < 0.5 τότε προς τα κάτω, αλλιώς προς τα πάνω | Αν το κλασματικό μέρος < 0.5, στρογγυλοποίηση προς τα πάνω, αλλιώς προς τα κάτω | <span class="p-style">round(2.3)=2.0</span>, <span class="p-style">round(2.7)=3.0</span>, <span class="p-style">round(-2.3)=-2.0</span>, <span class="p-style">round(-2.7)=-3.0</span> |


Σχετική είναι και η συνάρτηση <span class="p-style">modf()</span> που χωρίζει μια πραγματική τιμή σε ακέραιο και δεκαδικό μέρος.
Το ακόλουθο πρόγραμμα (κώδικας 17.14) δείχνει τη χρήση αυτών των συναρτήσεων.


```{.c title="Κώδικας 17.14: ch17_p14.c - παραδείγματα με συναρτήσεις στρογγυλοποίησης, αποκοπής δεκαδικών κ.λπ." linenums="1"}
--8<-- "src/ch17_p14.c"
```

Ακολουθεί η έξοδος του προγράμματος.

```
    x   floor   ceiling round   trunc   integer_part    fractional_part
  2.3     2.0       3.0   2.0     2.0            2.0                0.3
 ‐2.3    ‐3.0      ‐2.0  ‐2.0    ‐2.0           ‐2.0               ‐0.3
  2.7     2.0       3.0   3.0     2.0            2.0                0.7
 ‐2.7    ‐3.0      ‐2.0  ‐3.0    ‐2.0           ‐2.0               ‐0.7
```

Μια άλλη συνάρτηση του <span class="p-style">math.h</span> είναι η <span class="p-style">fmod()</span>, που υπολογίζει το υπόλοιπο της διαίρεσης δύο αριθμών κινητής υποδιαστολής. Ειδικότερα, όπως αναφέρεται στην τεκμηρίωση της συνάρτησης(1), η <span class="p-style">fmod(x, y)</span> επιστρέφει την τιμή <span class="p-style">𝑥 − 𝑖 ∗ 𝑦</span> για κάποιον ακέραιο <span class="p-style">𝑖</span>τέτοιο ώστε, αν το <span class="p-style">𝑦</span> δεν είναι μηδενικό, το αποτέλεσμα να έχει το ίδιο πρόσημο με το <span class="p-style">𝑥</span> και τιμή μικρότερη ή ίση της τιμής του <span class="p-style">𝑦</span>. Υπενθυμίζεται ότι η ακέραια διαίρεση και το ακέραιο υπόλοιπο της διαίρεσης, υπολογίζονται μέσω των τελεστών <span class="p-style">/</span> και <span class="p-style">%</span>, όταν οι τελεστέοι είναι ακέραιοι. Στο ακόλουθο παράδειγμα (κώδικας 17.15) φαίνεται η χρήση της <span class="p-style">fmod()</span>.
{ .annotate }

1. Η εμφάνιση της περιγραφής της λειτουργίας της συνάρτησης <span class="p-style">fmod()</span> γίνεται με την εντολή “man fmod” στη γραμμή εντολών σε συστήματα Linux ή MacOS.

```{.c title="Κώδικας 17.15: ch17_p15.c - υπόλοιπο διαίρεσης δύο πραγματικών αριθμών για διαίρεση με ακέραιο πηλίκο." linenums="1"}
--8<-- "src/ch17_p15.c"
```

Το πρόγραμμα κατά την εκτέλεσή του θα εμφανίσει:

```
The value 4.4 fits 2 times in 10.0 and the remainder is 1.2
```

Οι τριγωνομετρικές συναρτήσεις του <span class="p-style">math.h</span> αποτελούν μια ακόμη κατηγορία συναρτήσεών του. Πέρα από τις συναρτήσεις <span class="p-style">sin()</span>, <span class="p-style">cos()</span>, <span class="p-style">tan()</span> για ημίτονο, συνημίτονο και εφαπτομένη, που αναφέρθηκαν ήδη, υπάρχουν οι συναρτήσεις <span class="p-style">asin()</span>, <span class="p-style">acos()</span>, <span class="p-style">atan()</span> και <span class="p-style">atan2()</span>, που υπολογίζουν τόξα τριγωνομετρικών συναρτήσεων. Οι τριγωνομετρικές συναρτήσεις δέχονται ως ορίσματα γωνίες κύκλων σε ακτίνια (radians), οπότε αν οι διαθέσιμες τιμές είναι σε μοίρες (degrees) τότε θα πρέπει πρώτα να μετατραπούν. Η μετατροπή γίνεται με βάση την εξίσωση <span class="p-style">1𝜋 = 180∘</span>, από όπου προκύπτει ότι η μετατροπή μοιρών σε ακτίνια γίνεται πολλαπλασιάζοντας τις μοίρες επί 0.0174532925, ενώ η μετατροπή ακτινίων σε μοίρες γίνεται πολλαπλασιάζοντας τα ακτίνια επί 57.2957795. Ο κώδικας 17.16 είναι ένα παράδειγμα χρήσης τριγωνομετρικών συναρτήσεων.



```{.c title="Κώδικας 17.16: ch17_p16.c - εμφάνιση τιμών ημιτόνου, συνημιτόνου και εφαπτομένης για τις γωνίες: 𝜋, 𝜋/2 , 𝜋/3 , 𝜋/4 , 𝜋/6 ." linenums="1"}
--8<-- "src/ch17_p16.c"
```

Ακολουθεί η έξοδος του προγράμματος:

```
3.141593(rad)=180(deg): sin=+0.000000, cos=‐1.000000, tan=‐0.000000
1.570796(rad)= 90(deg): sin=+1.000000, cos=+0.000000, tan=+16331239353195370.000000
1.047198(rad)= 60(deg): sin=+0.866025, cos=+0.500000, tan=+1.732051
0.785398(rad)= 45(deg): sin=+0.707107, cos=+0.707107, tan=+1.000000
0.523599(rad)= 30(deg): sin=+0.500000, cos=+0.866025, tan=+0.577350
```

Στη γραμμή 5, η τιμή του <span class="p-style">𝜋</span> λαμβάνεται με το τόξο συνημιτόνου του -1. Η κλήση <span class="p-style">acos(‐1)</span> επιστρέφει σε ακτίνια τη γωνία που το συνημίτονό της είναι -1, δηλαδή τη γωνία <span class="p-style">𝜋</span>. Η τιμή <span class="p-style">𝜋</span> θα μπορούσε επίσης να ληφθεί με την έκφραση <span class="p-style">4.0 * atan(1.0)</span>, καθώς η εφαπτομένη των <span class="p-style">𝜋/4 = 45∘</span> είναι 1.0, ή με τη σταθερά <span class="p-style">M_PI</span> της <span class="p-style">math.h</span> (προστέθηκε με το πρότυπο C99). Ένα ακόμα σημείο με ενδιαφέρον στα αποτελέσματα είναι ότι η τιμή της εφαπτομένης που εμφανίζεται για τις <span class="p-style">𝜋/2 = 90∘</span> είναι μια πολύ μεγάλη τιμή. Τυπικά, θα έπρεπε να υπήρχε κάποιος έλεγχος ξεχωριστά για την περίπτωση αυτή και όχι να εμφανίζεται μια αυθαίρετα μεγάλη τιμή. Ας σημειωθεί ότι καθώς η γωνία <span class="p-style">𝜋/2</span> προσεγγίζεται από αριστερά (δηλαδή από μικρότερες τιμές), η τιμή της εφαπτομένης προσεγγίζει το <span class="p-style">-∞</span>, ενώ όταν αυτό συμβαίνει από δεξιά (δηλαδή από μεγαλύτερες τιμές) η τιμή της εφαπτομένης προσεγγίζει το <span class="p-style">+∞</span>. Αυτό φαίνεται στον κώδικα 17.17.

```{.c title="Κώδικας 17.17: ch17_p17.c - τιμές της εφαπτομένης καθώς η τιμή μιας γωνίας προσεγγίζει από δεξιά και από αριστερά τις 90∘." linenums="1"}
--8<-- "src/ch17_p17.c"
```

Ακολουθούν τα αποτελέσματα εκτέλεσης του κώδικα:

```
1.470796(rad)=84.270422(deg): tan=+9.96664
1.560796(rad)=89.427042(deg): tan=+99.99667
1.569796(rad)=89.942704(deg): tan=+999.99967
1.570696(rad)=89.994270(deg): tan=+9999.99997
1.570786(rad)=89.999427(deg): tan=+100000.00000
1.570806(rad)=90.000573(deg): tan=‐100000.00000
1.570896(rad)=90.005730(deg): tan=‐9999.99997
1.571796(rad)=90.057296(deg): tan=‐999.99967
1.580796(rad)=90.572958(deg): tan=‐99.99667
1.670796(rad)=95.729578(deg): tan=‐9.96664
```

Οι τριγωνομετρικές συναρτήσεις τυπικά δέχονται ορίσματα <span class="p-style">double</span> και επιστρέφουν τιμές <span class="p-style">double</span>. Από το πρότυπο C99 και μετά υπάρχουν οι τριγωνομετρικές συναρτήσεις με ονόματα που τελειώνουν σε <span class="p-style">f</span> και σε <span class="p-style">l</span>, όπως για παράδειγμα οι <span class="p-style">sinf()</span>, <span class="p-style">sinl()</span>, που δέχονται ως ορίσματα, αλλά και επιστρέφουν <span class="p-style">float</span> και <span class="p-style">long</span> <span class="p-style">double</span> τιμές αντίστοιχα, αντί για <span class="p-style">double</span>. Επίσης, με το πρότυπο C99 προστέθηκε το <span class="p-style">tgmath.h</span> που ορίζει μακροεντολές όπως η <span class="p-style">sin</span> που παρέχουν γενερική (generic) πρόσβαση στις τριγωνομετρικές συναρτήσεις, καλώντας την κατάλληλη συνάρτηση ανάλογα με τον τύπο των ορισμάτων. Ο κώδικας 17.18 αποτελεί ένα παράδειγμα χρήσης αυτών των συναρτήσεων.

```{.c title="Κώδικας 17.18: ch17_p18.c - χρήση της μακροεντολής sin για κλήση της κατάλληλης συνάρτησης με βάση τον τύπο του ορίσματος." linenums="1"}
--8<-- "src/ch17_p18.c"
```

Η έξοδος του προγράμματος είναι η ακόλουθη:

```
sinf(1.137169242) using macro=0.907447755
sin(1.13716927413690527) using macro=0.90744776169021168
sinl(1.137169274136905272599) using macro=0.907447761690211684993
```

Στις γραμμές 14-17 εκτελείται τρεις φορές η μακροεντολή <span class="p-style">sin</span> και με βάση το όρισμα που δέχεται, καλεί την κατάλληλη συνάρτηση ανάμεσα στις <span class="p-style">sinf()</span>, <span class="p-style">sin()</span> και <span class="p-style">sinl()</span>.

### 17.1.5 time.h

Το αρχείο επικεφαλίδας <span class="p-style">time.h</span> ορίζει διάφορους τύπους δεδομένων σχετικούς με τον χρόνο, όπως τον <span class="p-style">time_t</span>, τον <span class="p-style">clock_t</span> και τον <span class="p-style">struct tm</span>, που θα παρουσιαστούν στη συνέχεια μαζί με συναρτήσεις που τους χρησιμοποιούν και παραδείγματα.  
Ο τύπος δεδομένων <span class="p-style">time_t</span> σε συστήματα που υποστηρίζουν το POSIX, είναι ένας ακέραιος τύπος με εύρος τιμών ικανό να αναπαραστήσει το πλήθος δευτερολέπτων που έχουν παρέλθει από το λεγόμενο epoch που είναι η 1η Ιανουαρίου του 1970 στις 00:00:00 UTC (Coordinated Universal Time). Η συνάρτηση <span class="p-style">time()</span> μπορεί να χρησιμοποιηθεί για να επιστραφεί το πλήθος των δευτερολέπτων της τρέχουσας χρονικής στιγμής από το epoch, ενώ οι συναρτήσεις <span class="p-style">difftime()</span> και <span class="p-style">ctime()</span> χρησιμοποιούνται για τον υπολογισμό της απόστασης σε δευτερόλεπτα ανάμεσα σε δύο τιμές τύπου <span class="p-style">time_t</span> και για την εμφάνιση τιμών τύπου <span class="p-style">time_t</span> ως αλφαριθμητικά χρονικών στιγμών (ημερομηνία και ώρα) αντίστοιχα. Στο ακόλουθο παράδειγμα (κώδικας 17.19) χρησιμοποιούνται οι συναρτήσεις που αναφέρθηκαν και η συνάρτηση <span class="p-style">sleep()</span> που προκαλεί παύση της εκτέλεσης για ένα διάστημα που δίνεται σε δευτερόλεπτα. Η συνάρτηση <span class="p-style">sleep()</span> ορίζεται στο αρχείο επικεφαλίδας <span class="p-style">unistd.h</span>.

```{.c title="Κώδικας 17.19: ch17_p19.c - χρήση της συνάρτησης sleep() για προσωρινή παύση εκτέλεσης." linenums="1"}
--8<-- "src/ch17_p19.c"
```

Ακολουθεί ένα αποτέλεσμα εκτέλεσης:

```
Time1: Sun Jul 23 16:58:01 2023
Time2: Sun Jul 23 16:58:03 2023
Time gap between prints: 2 seconds
```

Ο τύπος <span class="p-style">clock_t</span> μπορεί να χρησιμοποιηθεί για να αποθηκεύσει μια τιμή ανάλογη του πλήθους των χτύπων (ticks) του ρολογιού από την αρχή εκτέλεσης του προγράμματος μέχρι το σημείο όπου καλείται η συνάρτηση <span class="p-style">clock()</span>. Ως χτύπος ρολογιού μπορεί να θεωρηθεί ότι είναι ο χρόνος που απαιτείται για να εκτελεστεί μια μικροεντολή στην ΚΜΕ (Κεντρική Μονάδα Επεξεργασίας). Για να μετατραπεί η τιμή που επιστρέφει η <span class="p-style">clock()</span> σε χρόνο διαιρείται με τη σταθερά <span class="p-style">CLOCKS_PER_SEC</span>, οπότε επιστρέφεται μια δεκαδική τιμή που αναπαριστά δευτερόλεπτα. Ο τύπος <span class="p-style">clock_t</span> χρησιμοποιείται συχνά για να μετρήσει τον χρόνο εκτέλεσης κώδικα ανάμεσα σε δύο σημεία ενδιαφέροντος στον κώδικα. Ένα σχετικό παράδειγμα παρουσιάζεται στον κώδικα 17.20 που ακολουθεί:

```{.c title="Κώδικας 17.20: ch17_p20.c - χρονομέτρηση κώδικα." linenums="1"}
--8<-- "src/ch17_p20.c"
```

Ακολουθεί ένα αποτέλεσμα εκτέλεσης. Ας σημειωθεί ότι η σταθερά <span class="p-style">CLOCKS_PER_SEC</span> έχει την προκαθορισμένη τιμή 1000000, ανεξάρτητα του υλικού του συστήματος που εκτελεί τον κώδικα.

```
CLOCKS_PER_SEC=1000000, start=3664, end=122949
Result=5000000050000000
Elapsed time=0.119285 seconds
```

Ένας άλλος τύπος δεδομένων του <span class="p-style">time.h</span>, που επιτρέπει τον χειρισμό ημερομηνιών και ωρών, είναι η δομή <span class="p-style">struct tm</span> που παρατίθεται στη συνέχεια:

```{.c}
struct tm {
int tm_sec; // δευτερόλεπτα , 0‐59
int tm_min; // λεπτά, 0‐59
int tm_hour; // ώρες, 0‐23
int tm_mday; // ημέρα μήνα, 1‐31
int tm_mon; // μήνας, 0‐11
int tm_year; // πλήθος ετών από το 1900
int tm_wday; // ημέρα εβδομάδας από την Κυριακή , 0‐6
int tm_yday; // πλήθος ημερών από 1η Ιανουαρίου , 0‐365
int tm_isdst; // > 0 για θερινή ώρα, 0 για χειμερινή , < 0 για μη διαθέσιμη πληροφορία
};
```

Υπάρχουν διάφορες συναρτήσεις που χρησιμοποιούν το <span class="p-style">struct tm</span>, όπως η <span class="p-style">gmtime()</span>, η <span class="p-style">localtime()</span>, η <span class="p-style">asctime()</span> και η <span class="p-style">strftime()</span>. Η <span class="p-style">gmtime()</span> μετατρέπει μια τιμή <span class="p-style">time_t</span> σε <span class="p-style">struct tm</span>, όπως και η <span class="p-style">locatime()</span> με τη διαφορά ότι η πρώτη κάνει τη μετατροπή σε UTC χρόνο, ενώ η δεύτερη σε τοπικό χρόνο. Ο κώδικας 17.21 αποτελεί ένα παράδειγμα όπου λαμβάνεται η τρέχουσα ημέρα και ώρα κατά την εκτέλεση ως <span class="p-style">time_t</span> και μετατρέπεται με τη <span class="p-style">gmtime()</span> σε <span class="p-style">struct tm</span>. Στη συνέχεια μετατρέπεται με την <span class="p-style">asctime()</span> η <span class="p-style">struct tm</span> σε αλφαριθμητικό ημερομηνίας και ώρας προκειμένου να εμφανιστεί. Μετά, προστίθεται 1 ημέρα και 10 ώρες στη δομή και μετατρέπεται σε <span class="p-style">time_t</span>, πριν τελικά μετατραπεί ξανά με τη <span class="p-style">gmtime()</span> σε <span class="p-style">struct tm</span>. Αυτή η διπλή μετατροπή γίνεται προκειμένου να περιοριστούν οι τιμές των επιμέρους πεδίων του <span class="p-style">struct tm</span> σε έγκυρες τιμές (π.χ. να μην υπάρχει τιμή μεγαλύτερη του 23 για τις ώρες). Τέλος, χρησιμοποιείται η συνάρτηση <span class="p-style">strftime()</span> για να τοποθετηθεί σε έναν πίνακα χαρακτήρων το αλφαριθμητικό εξόδου με την ημερομηνία και ώρα. Η <span class="p-style">strftime()</span> χρησιμοποιεί ως τρίτο στη σειρά όρισμα ένα αλφαριθμητικό που καθορίζει με ειδικούς κωδικούς μορφοποίησης(1) τη μορφή που θα έχει το αποτέλεσμα.
{ .annotate }

1. <a href="https://en.cppreference.com/w/c/chrono/strftime" target="_blank">https://en.cppreference.com/w/c/chrono/strftime</a>

```{.c title="Κώδικας 17.21: ch17_p21.c - προσθήκη ενός χρονικού διαστήματος σε μια ημερομηνία και εμφάνιση της νέας  ημερομηνίας." linenums="1"}
--8<-- "src/ch17_p21.c"
```

Ακολουθεί ένα αποτέλεσμα εκτέλεσης. Το ίδιο παράδειγμα θα μπορούσε να χρησιμοποιεί την τοπική ώρα αν όλες οι κλήσεις της <span class="p-style">gmtime()</span> είχαν αντικατασταθεί με κλήσεις της <span class="p-style">localtime()</span>.

```
UTC time=Sun Jul 23 16:00:41 2023
UTC time(+1day, 10hours)=Tuesday Tue Jul 25 02:00:41 2023
```

## 17.2 Εξωτερικές βιβλιοθήκες της C

Ένα μεγάλο πλεονέκτημα της C είναι η πληθώρα βιβλιοθηκών που υπάρχουν για την εξυπηρέτηση διαφόρων αναγκών όπως δημιουργία γραφικών διεπαφών (π.χ. GTK+, IUP), προχωρημένες δυνατότητες μαθηματικών (π.χ. GSL, BLAS, GMP), αλληλεπίδραση με βάσεις δεδομένων (π.χ. SQLite), γραφικά (π.χ. SDL, SIGIL), επικοινωνίες (π.χ. libcurl, ZeroMQ) και άλλα. Μια λίστα με εξωτερικές βιβλιοθήκες ανοικτού κώδικα της C μπορεί να εντοπιστεί στο [^1]. Επίσης, σελίδες τύπου awesome(1) όπως η [^2] περιέχουν συνδέσμους προς βιβλιοθήκες και άλλα ενδιαφέροντα θέματα σχετικά με τη C, οργανωμένα σε κατηγορίες.
{ .annotate }

1. <a href="https://github.com/topics/awesome-list" target="_blank">https://github.com/topics/awesome-list</a> 

Στη συνέχεια θα παρουσιαστεί ένα παράδειγμα εγκατάστασης και χρήσης της εξωτερικής βιβλιοθήκης GSL. Υπάρχουν διάφοροι τρόποι για την εγκατάσταση βιβλιοθηκών της C, που εξαρτώνται από το λειτουργικό σύστημα και την ίδια τη βιβλιοθήκη. Για παράδειγμα υπάρχουν βιβλιοθήκες που είναι “header only” που σημαίνει ότι αρκεί να μεταφορτωθεί ένα αρχείο επικεφαλίδας και στη συνέχεια απλά να γίνει include έτσι ώστε να χρησιμοποιηθεί η βιβλιοθήκη στον κώδικα. Ωστόσο, συχνότερα, οι βιβλιοθήκες πρέπει να εγκαθίστανται προκειμένου να χρησιμοποιηθούν. Στο Linux υπάρχουν οι λεγόμενοι διαχειριστές πακέτων (package managers), που επιτρέπουν την εγκατάσταση βιβλιοθηκών και άλλων λογισμικών. Έτσι, η βιβλιοθήκη GSL μπορεί να εγκατασταθεί, για παράδειγμα, σε μια διανομή Ubuntu, με την ακόλουθη εντολή:

```
$ sudo apt‐get install libgsl‐dev
```

Αυτό που συμβαίνει με μια τέτοια εντολή είναι ότι αντιγράφονται στον υπολογιστή όλα τα απαιτούμενα αρχεία της βιβλιοθήκης GSL, και το λειτουργικό σύστημα ενημερώνεται για τις θέσεις των αρχείων επικεφαλίδας και των δυαδικών αρχείων της βιβλιοθήκης. Η εγκατάσταση της βιβλιοθήκης σε MacOS μπορεί να γίνει με παρόμοιο τρόπο, εφόσον πρώτα εγκατασταθεί ένας διαχειριστής πακέτων όπως ο HomeBrew ή ο MacPorts. Στα Windows η εγκατάσταση δεν είναι το ίδιο εύκολη καθώς δεν διατίθεται επίσημος διαχειριστής πακέτων και οι λύσεις που προτείνονται, όπως το chocolatey, προσφέρουν δυνατότητα εγκατάστασης μόνο για κάποιες βιβλιοθήκες και λογισμικά. Για να γεφυρωθούν οι διαφορές στον τρόπο εγκατάστασης των εξωτερικών βιβλιοθηκών ανάμεσα στα διάφορα λειτουργικά συστήματα και τις εκδόσεις τους, μπορεί να χρησιμοποιηθεί το λογισμικό vcpkg (<a href="https://github.com/microsoft/vcpkg" target="_blank">https://github.com/microsoft/vcpkg</a>)  
Το vcpkg είναι ένα σύστημα διαχείρισης εγκαταστάσεων βιβλιοθηκών για τη C και τη C++. Έχει αναπτυχθεί από τη Microsoft και επιτρέπει την αυτοματοποίηση της λήψης, της μεταγλώττισης και σύνδεσης (build), καθώς και της εγκατάστασης βιβλιοθηκών C και C++ σε συστήματα Windows, Linux και MacOS. Ο σκοπός του είναι να απλοποιήσει τη διαδικασία ανάπτυξης λογισμικού με αυτοματοποίηση της διαχείρισης εγκατάστασης βιβλιοθηκών.  
Οι οδηγίες εγκατάστασης του vcpkg βρίσκονται στο <a href="https://vcpkg.io/en/getting‐started.html" target="_blank">https://github.com/microsoft/vcpkg</a>. Από τη στιγμή που έχει εγκατασταθεί η εγκατάσταση των βιβλιοθηκών γίνεται με εντολές της μορφής:

```
$ vcpkg install [βιβλιοθήκη προς εγκατάσταση]
```

Για παράδειγμα, η βιβλιοθήκη GSL εγκαθίσταται με την εντολή:

```
$ vcpkg install gsl
```

Το vcpkg ανιχνεύει το υπολογιστικό σύστημα στο οποίο εκτελείται και εγκαθιστά την κατάλληλη έκδοση της βιβλιοθήκης. Το vcpkg χρησιμοποιεί τις λεγόμενες τριάδες (triplets) στη διαχείριση των διαφορετικών διαμορφώσεων κατά την εγκατάσταση των βιβλιοθηκών. Κάθε τριάδα αντιπροσωπεύει μια πλατφόρμα, αρχιτεκτονική και πρόσθετες ρυθμίσεις. Για παράδειγμα η τριάδα <span class="p-style">x64‐linux‐dynamic</span> σημαίνει ότι η αρχιτεκτονική της πλατφόρμας είναι 64 bits, το λειτουργικό σύστημα είναι linux και θα δημιουργηθεί βιβλιοθήκη για δυναμική σύνδεση. Συνεπώς, η βιβλιοθήκη GSL θα μπορούσε να είχε εγκατασταθεί και με την ακόλουθη εντολή:

```
$ vcpkg install gsl:x64‐linux‐dynamic
```

Για να μπορεί να χρησιμοποιηθεί η βιβλιοθήκη GSL θα πρέπει να οριστούν κατά τη μεταγλώττιση και σύνδεση μέσω των διακοπτών <span class="p-style">‐I</span> και <span class="p-style">‐L</span> οι κατάλληλες διαδρομές προς τα αρχεία επικεφαλίδας και τα δυαδικά αρχεία της βιβλιοθήκης. Στο παράδειγμα του κώδικα 17.22 χρησιμοποιείται η δυνατότητα της GSL να δημιουργεί όλες τις μεταθέσεις (permutations) των στοιχείων ενός συνόλου.

```{.c title="Κώδικας 17.22: ch17_p22.c - παραγωγή όλων των μεταθέσεων ενός συνόλου αλφαριθμητικών, με την εξωτερική βιβλιοθήκη GSL." linenums="1"}
--8<-- "src/ch17_p22.c"
```

Η μεταγλώττιση του κώδικα θα γίνει με τις ακόλουθες εντολές μεταγλώττισης ανά περίπτωση. Σε Windows, υποθέτοντας ότι ο χρήστης του συστήματος έχει όνομα <span class="p-style">a_user</span> και ότι το vcpkg έχει εγκατασταθεί στον κατάλογο <span class="p-style">c:\Users\a_user</span>, η μεταγλώττιση θα πρέπει να γίνει με την ακόλουθη εντολή:

```
> gcc ch17_p22.c ‐IC:\Users\a_user\vcpkg\installed\x64‐windows\include
    ↪ ‐LC:\Users\a_user\vcpkg\installed\x64‐windows\lib ‐lgsl ‐lgslcblas ‐lm
```

Στα Windows θα πρέπει να τοποθετηθούν τα αρχεία <span class="p-style">gsl.dll</span> και <span class="p-style">gslcblas.dll</span> στον ίδιο κατάλογο με το εκτελέσιμο. Τα αρχεία αυτά έχουν δημιουργηθεί κατά την εγκατάσταση και βρίσκονται στη διαδρομή <span class="p-style">C:\Users\a_user\vcpkg\installed\x64‐windows\bin</span>. Εναλλακτικά, αυτή η διαδρομή μπορεί να προστεθεί στο <span class="p-style">PATH</span>, οπότε δεν θα απαιτούνταν η αντιγραφή των αρχείων <span class="p-style">gsl.dll</span> και <span class="p-style">gslcblas.dll</span>.  
Σε Linux υποθέτοντας ότι ο χρήστης του συστήματος έχει όνομα <span class="p-style">a_user</span> και ότι το vcpkg έχει εγκατασταθεί στον γονικό κατάλογο (<span class="p-style">/home/a_user</span>), η μεταγλώττιση θα πρέπει να γίνει με την ακόλουθη εντολή:

```
$ gcc ch17_p22.c ‐I/home/a_user/vcpkg/installed/x64‐linux/include
    ↪ ‐L/home/a_user/vcpkg/installed/x64‐linux/lib ‐lgsl ‐lgslcblas ‐lm
```

Σε MacOS (αρχιτεκτονικής arm64) υποθέτοντας ότι ο χρήστης του συστήματος έχει όνομα <span class="p-style">a_user</span> και ότι το vcpkg έχει εγκατασταθεί στον γονικό κατάλογο (<span class="p-style">/Users/a_user</span>), η μεταγλώττιση θα πρέπει να γίνει με την ακόλουθη εντολή:

```
$ gcc ch17_p22.c ‐I/Users/a_user/vcpkg/installed/arm64‐osx/include/
    ↪ ‐L/Users/a_user/vcpkg/installed/arm64‐osx/lib ‐lgsl ‐lgslcblas ‐lm
```

Τα αποτελέσματα εκτέλεσης θα είναι και στις 3 περιπτώσεις τα ακόλουθα:

```
Alice Bob Charlie
Alice Charlie Bob
Bob Alice Charlie
Bob Charlie Alice
Charlie Alice Bob
Charlie Bob Alice
```
Αξίζει να σημειωθεί ότι το vcpkg συνεργάζεται καλά με το CMAKE καθώς και με το pkg-config. Η ανάπτυξη των συγκεκριμένων δυνατοτήτων του vcpkg είναι εκτός του αντικειμένου του παρόντος συγγράμματος.


## 17.3 Ασκήσεις

***Άσκηση 1***  
Γράψτε ένα πρόγραμμα που ο χρήστης θα προσπαθεί να εντοπίσει, με τον μικρότερο αριθμό προσπαθειών, έναν ακέραιο αριθμό, που θα έχει δημιουργηθεί τυχαία σε ένα εύρος τιμών (π.χ. 1 έως 100). Το πρόγραμμα θα ζητά από τον χρήστη να μαντέψει τον αριθμό και σε περίπτωση αποτυχίας θα εμφανίζει μήνυμα σχετικά με το εάν ο αριθμός που επιλέχθηκε είναι μικρότερος ή μεγαλύτερος από τον αριθμό που αναζητείται. Όταν ο χρήστης πετύχει τον αριθμό, το πρόγραμμα θα σταματά και θα εμφανίζει το πλήθος των προσπαθειών που χρειάστηκαν για τον εντοπισμό του.

***Άσκηση 2***  
Γράψτε ένα πρόγραμμα που να ζητά από τον χρήστη να εισάγει δύο ημερομηνίες, σε μορφή έτους, μήνα, ημέρας. Το πρόγραμμα να μετατρέπει τις ημερομηνίες σε <span class="p-style">time_t</span>, να υπολογίζει τη διαφορά τους σε ημέρες και να την εμφανίζει.

***Άσκηση 3***  
Γράψτε ένα πρόγραμμα που να υπολογίζει χρησιμοποιώντας επανάληψη πόσες φορές χρειάζεται να υποδιπλασιαστεί μια ποσότητα έτσι ώστε να γίνει ίση ή μικρότερη από μια άλλη ποσότητα. Υπολογίστε την ίδια τιμή με χρήση λογαριθμικής συνάρτησης από το <span class="p-style">math.h</span>.

***Άσκηση 4***  
Δημιουργήστε δύο ίσου μεγέθους πίνακες με τυχαίες τιμές, στο εύρος τιμών από 1 μέχρι 100, που ο χρήστης θα δίνει το πλήθος των στοιχείων τους. Χρησιμοποιήστε τη βιβλιοθήκη GSL για να επιτύχετε τον υπολογισμό του εσωτερικού γινομένου των δύο πινάκων.

[^1]: cppreference.com: A list of open source C libraries.</i> <a href="https://en.cppreference.com/w/c/links/libs" target="_blank">https://en.cppreference.com/w/c/links/libs</a>. [Online; accessed 2023-July-12].  

[^2]: <i>Awesome-c: Curated list of awesome lists.</i> <a href="https://project-awesome.org/inputsh/awesome-c" target="_blank">https://project-awesome.org/inputsh/awesome-c</a>.[Online; accessed 2023-July-12].